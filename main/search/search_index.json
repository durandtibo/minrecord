{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>TODO</p>"},{"location":"#motivation","title":"Motivation","text":"<p>TODO</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>minrecord</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>minrecord</code> to a new version will possibly break any code that was using the old version of <code>minrecord</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>minrecord</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install minrecord\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>minrecord</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'minrecord[all]'\n</code></pre> <p>This command also installed NumPy and PyTorch. It is also possible to install the optional packages manually or to select the packages to install. In the following example, only NumPy is installed:</p> <pre><code>pip install minrecord numpy\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>minrecord</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/minrecord.git\n</code></pre> <p>It is recommended to create a Python 3.9+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate minrecord\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>minrecord</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/comparator/","title":"minrecord.comparator","text":""},{"location":"refs/comparator/#minrecord.comparator","title":"minrecord.comparator","text":"<p>Contain the comparator base class and some implementations.</p>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator","title":"minrecord.comparator.BaseComparator","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Define the base comparator class to implement a comparator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator.equal","title":"minrecord.comparator.BaseComparator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two comparators are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the comparators are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator, MaxScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.equal(MinScalarComparator())\nTrue\n&gt;&gt;&gt; comparator.equal(MaxScalarComparator())\nFalse\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator.get_initial_best_value","title":"minrecord.comparator.BaseComparator.get_initial_best_value  <code>abstractmethod</code>","text":"<pre><code>get_initial_best_value() -&gt; T\n</code></pre> <p>Get the initial best value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The initial best value.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator.is_better","title":"minrecord.comparator.BaseComparator.is_better  <code>abstractmethod</code>","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.ComparatorEqualityComparator","title":"minrecord.comparator.ComparatorEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[BaseComparator]</code></p> <p>Implement an equality comparator for <code>BaseBatch</code> objects.</p>"},{"location":"refs/comparator/#minrecord.comparator.MaxScalarComparator","title":"minrecord.comparator.MaxScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implement a max comparator for scalar value.</p> <p>This comparator can be used to find the maximum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarComparator\n&gt;&gt;&gt; comparator = MaxScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nTrue\n&gt;&gt;&gt; comparator.get_initial_best_value()\n-inf\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.MinScalarComparator","title":"minrecord.comparator.MinScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implementation of a min comparator for scalar value.</p> <p>This comparator can be used to find the minimum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/","title":"minrecord","text":""},{"location":"refs/root/#minrecord","title":"minrecord","text":"<p>Root package.</p>"},{"location":"refs/root/#minrecord.BaseComparator","title":"minrecord.BaseComparator","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Define the base comparator class to implement a comparator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/#minrecord.BaseComparator.equal","title":"minrecord.BaseComparator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two comparators are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the comparators are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator, MaxScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.equal(MinScalarComparator())\nTrue\n&gt;&gt;&gt; comparator.equal(MaxScalarComparator())\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.BaseComparator.get_initial_best_value","title":"minrecord.BaseComparator.get_initial_best_value  <code>abstractmethod</code>","text":"<pre><code>get_initial_best_value() -&gt; T\n</code></pre> <p>Get the initial best value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The initial best value.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/#minrecord.BaseComparator.is_better","title":"minrecord.BaseComparator.is_better  <code>abstractmethod</code>","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord","title":"minrecord.BaseRecord","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Define the base class to implement a record.</p> <p>The record tracks the value added as well as the step when the value is added. The goal of this class is to track the recent record because the loggers (e.g. MLFlow or Tensorboard) do not allow to get the last value or the best value. The record keeps in memory a recent record of pairs (step, value) where step is the index of the step when the value was added. The length of the recent record depends on the concrete implementation.</p> <p>To implement your own record, you will need to define the following methods:</p> <pre><code>- ``add_value``\n- ``get_last_value``\n- ``get_most_recent``\n- ``is_comparable``\n- ``is_empty``\n- ``update``\n- ``load_state_dict``\n- ``state_dict``\n</code></pre> <p>If it is a comparable record, you will need to implement the following methods too:</p> <pre><code>- ``_get_best_value``\n- ``_has_improved``\n</code></pre> <p>You may also need to extend the <code>config_dict</code> method.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.get_last_value()\n1.2\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.name","title":"minrecord.BaseRecord.name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the record.</p>"},{"location":"refs/root/#minrecord.BaseRecord.add_value","title":"minrecord.BaseRecord.add_value  <code>abstractmethod</code>","text":"<pre><code>add_value(value: T, step: float | None = None) -&gt; None\n</code></pre> <p>Add a new value to the record.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to add to the record.</p> required <code>step</code> <code>float | None</code> <p>The step value to record. <code>None</code> means there is no step to track.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2)\n&gt;&gt;&gt; record.add_value(value=42, step=1)\n&gt;&gt;&gt; record\nRecord(\n  (name): loss\n  (max_size): 10\n  (record): ((None, 2), (1, 42))\n)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.clone","title":"minrecord.BaseRecord.clone","text":"<pre><code>clone() -&gt; BaseRecord\n</code></pre> <p>Clone the current record.</p> <p>Returns:</p> Type Description <code>BaseRecord</code> <p>A copy of the current record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"epoch\")\n&gt;&gt;&gt; record_cloned = record.clone()\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.config_dict","title":"minrecord.BaseRecord.config_dict","text":"<pre><code>config_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get the config of the record.</p> <p>The config dictionary should contain all the values necessary to instantiate a record with the same parameters with the  <code>factory</code> method. It is expected to contain values like the full name of the class and the arguments of the constructor. This dictionary should not contain the state values. It is possible to get the state values with the <code>state_dict</code> method.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The config of the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord, Record\n&gt;&gt;&gt; config = Record(\"loss\").config_dict()\n&gt;&gt;&gt; record = BaseRecord.factory(**config)  # Note that the state is not copied.\n&gt;&gt;&gt; record\nRecord(\n  (name): loss\n  (max_size): 10\n  (record): ()\n)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.equal","title":"minrecord.BaseRecord.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two records are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the records are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record1 = Record(\"loss\")\n&gt;&gt;&gt; record2 = Record(\"accuracy\")\n&gt;&gt;&gt; record3 = Record(\"loss\")\n&gt;&gt;&gt; record1.equal(record2)\nFalse\n&gt;&gt;&gt; record1.equal(record1)\nTrue\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.from_dict","title":"minrecord.BaseRecord.from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; BaseRecord\n</code></pre> <p>Instantiate a record from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary that is used to instantiate the record. The dictionary is expected to contain the parameters to create instantiate the record and the state of the record.</p> required <p>Returns:</p> Type Description <code>BaseRecord</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord\n&gt;&gt;&gt; from objectory import OBJECT_TARGET\n&gt;&gt;&gt; record = BaseRecord.from_dict(\n...     {\n...         \"config\": {\n...             OBJECT_TARGET: \"minrecord.Record\",\n...             \"name\": \"loss\",\n...             \"max_size\": 7,\n...         },\n...         \"state\": {\"record\": ((0, 1), (1, 5))},\n...     }\n... )\n&gt;&gt;&gt; record\nRecord(\n  (name): loss\n  (max_size): 7\n  (record): ((0, 1), (1, 5))\n)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.get_best_value","title":"minrecord.BaseRecord.get_best_value","text":"<pre><code>get_best_value() -&gt; T\n</code></pre> <p>Get the best value of this record.</p> <p>It is possible to get the best value only if it is a comparable record i.e. it is possible to compare the values in the record.</p> <p>Returns:</p> Type Description <code>T</code> <p>The best value of this record.</p> <p>Raises:</p> Type Description <code>NotAComparableRecord</code> <p>if it is not a comparable record.</p> <code>EmptyRecordError</code> <p>if the record is empty</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=4, step=1)\n&gt;&gt;&gt; record.get_best_value()\n4\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.get_last_value","title":"minrecord.BaseRecord.get_last_value  <code>abstractmethod</code>","text":"<pre><code>get_last_value() -&gt; T\n</code></pre> <p>Get the last value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The last value added in the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.get_last_value()\n1.2\n&gt;&gt;&gt; record.add_value(value=0.8, step=1)\n&gt;&gt;&gt; record.get_last_value()\n0.8\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.get_most_recent","title":"minrecord.BaseRecord.get_most_recent  <code>abstractmethod</code>","text":"<pre><code>get_most_recent() -&gt; tuple[tuple[float | None, T], ...]\n</code></pre> <p>Get the tuple of recent values and their associated steps.</p> <p>The last value in the tuple is the last value added to the record. The length of the recent record depends on the concrete implementation.</p> <p>Returns:</p> Type Description <code>tuple[tuple[float | None, T], ...]</code> <p>A tuple of the recent values in the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.add_value(value=0.8, step=2)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 2), (1, 1.2), (2, 0.8))\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.has_improved","title":"minrecord.BaseRecord.has_improved","text":"<pre><code>has_improved() -&gt; bool\n</code></pre> <p>Indicate if the last value is the best value.</p> <p>It is possible to use this method only if it is a comparable record i.e. it is possible to compare the values in the record.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the last value is the best value, otherwise <code>False</code>.</p> <p>Raises:</p> Type Description <code>NotAComparableRecord</code> <p>if it is not a comparable record.</p> <code>EmptyRecordError</code> <p>if the record is empty</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=4, step=1)\n&gt;&gt;&gt; record.has_improved()\nTrue\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.is_comparable","title":"minrecord.BaseRecord.is_comparable  <code>abstractmethod</code>","text":"<pre><code>is_comparable() -&gt; bool\n</code></pre> <p>Indicate if it is possible to compare the values in the record.</p> <p>Note that it is possible to compute the best value only for records that are comparable.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if it is possible to compare the values in the record, otherwise <code>False</code>.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_comparable()\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.is_empty","title":"minrecord.BaseRecord.is_empty  <code>abstractmethod</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Indicate if the record is empty or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the record is empty, otherwise <code>False</code>.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_empty()\nTrue\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.load_state_dict","title":"minrecord.BaseRecord.load_state_dict  <code>abstractmethod</code>","text":"<pre><code>load_state_dict(state_dict: dict[str, Any]) -&gt; None\n</code></pre> <p>Set up the record from a dictionary containing the state values.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict[str, Any]</code> <p>A dictionary containing state keys with values.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.load_state_dict({\"record\": ((0, 42.0),)})\n&gt;&gt;&gt; record.get_last_value()\n42.0\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.state_dict","title":"minrecord.BaseRecord.state_dict  <code>abstractmethod</code>","text":"<pre><code>state_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get a dictionary containing the state values of the record.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The state values in a dict.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(42.0, step=0)\n&gt;&gt;&gt; state = record.state_dict()\n&gt;&gt;&gt; state\n{'record': ((0, 42.0),)}\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.to_dict","title":"minrecord.BaseRecord.to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Export the current record to a dictionary.</p> <p>This method exports all the information to re-create the record with the same state. The returned dictionary can be used as input of the <code>from_dict</code> method to resume the record.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with the config and the state of the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord, Record\n&gt;&gt;&gt; record_dict = Record(\"loss\").to_dict()\n&gt;&gt;&gt; record = BaseRecord.from_dict(record_dict)\n&gt;&gt;&gt; record\nRecord(\n  (name): loss\n  (max_size): 10\n  (record): ()\n)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.update","title":"minrecord.BaseRecord.update  <code>abstractmethod</code>","text":"<pre><code>update(elements: Iterable[tuple[float | None, T]]) -&gt; None\n</code></pre> <p>Update the record by adding the elements.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The elements to add to the record.  Each tuple has the following structure <code>(step, value)</code>. The step can be <code>None</code> if there is no step.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.update([(0, 42), (1, 45)])\n&gt;&gt;&gt; record\nRecord(\n  (name): loss\n  (max_size): 10\n  (record): ((0, 42), (1, 45))\n)\n</code></pre>"},{"location":"refs/root/#minrecord.ComparableRecord","title":"minrecord.ComparableRecord","text":"<p>               Bases: <code>Record[T]</code></p> <p>Implement a record of comparable values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>comparator</code> <code>BaseComparator[T]</code> <p>The comparator to use to find the best value.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import ComparableRecord\n&gt;&gt;&gt; from minrecord.comparator import MaxScalarComparator\n&gt;&gt;&gt; record = ComparableRecord(\"value\", MaxScalarComparator())\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.ComparableRecord.is_better","title":"minrecord.ComparableRecord.is_better","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import ComparableRecord\n&gt;&gt;&gt; from minrecord.comparator import MaxScalarComparator\n&gt;&gt;&gt; record = ComparableRecord(\"accuracy\", MaxScalarComparator())\n&gt;&gt;&gt; record.is_better(new_value=1, old_value=0)\nTrue\n&gt;&gt;&gt; record.is_better(new_value=0, old_value=1)\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.EmptyRecordError","title":"minrecord.EmptyRecordError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise an error if the record is empty.</p>"},{"location":"refs/root/#minrecord.MaxScalarComparator","title":"minrecord.MaxScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implement a max comparator for scalar value.</p> <p>This comparator can be used to find the maximum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarComparator\n&gt;&gt;&gt; comparator = MaxScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nTrue\n&gt;&gt;&gt; comparator.get_initial_best_value()\n-inf\n</code></pre>"},{"location":"refs/root/#minrecord.MaxScalarRecord","title":"minrecord.MaxScalarRecord","text":"<p>               Bases: <code>ComparableRecord[Number]</code></p> <p>A specific implementation to track the max value of a scalar record.</p> <p>This record uses the <code>MaxScalarComparator</code> to find the best value of the record.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"value\")\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.MaxScalarRecord.from_elements","title":"minrecord.MaxScalarRecord.from_elements  <code>classmethod</code>","text":"<pre><code>from_elements(\n    name: str, elements: Iterable[tuple[float | None, T]]\n) -&gt; Self\n</code></pre> <p>Instantiate a <code>MaxScalarRecord</code> object from the elements.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord.from_elements(\"value\", ((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.MinScalarComparator","title":"minrecord.MinScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implementation of a min comparator for scalar value.</p> <p>This comparator can be used to find the minimum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/#minrecord.MinScalarRecord","title":"minrecord.MinScalarRecord","text":"<p>               Bases: <code>ComparableRecord[Number]</code></p> <p>A specific implementation to track the min value of a scalar record.</p> <p>This record uses the <code>MinScalarComparator</code> to find the best value of the record.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best  value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"value\")\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n42.0\n</code></pre>"},{"location":"refs/root/#minrecord.MinScalarRecord.from_elements","title":"minrecord.MinScalarRecord.from_elements  <code>classmethod</code>","text":"<pre><code>from_elements(\n    name: str, elements: Iterable[tuple[float | None, T]]\n) -&gt; Self\n</code></pre> <p>Instantiate a <code>MaxScalarRecord</code> object from the elements.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord.from_elements(\"value\", ((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.NotAComparableRecordError","title":"minrecord.NotAComparableRecordError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise an error if it is not possible to compare the values in the record.</p>"},{"location":"refs/root/#minrecord.Record","title":"minrecord.Record","text":"<p>               Bases: <code>BaseRecord[T]</code></p> <p>Implement a generic record to store the recent values.</p> <p>Internally, this class uses a <code>deque</code> to keep the most recent values added in the record. Note that this class does not allow to get the best value because it is not possible to define a generic rule to know the best object. Please see <code>ScalarRecord</code> that can compute the best value for scalars.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements in the record. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum size of the record.</p> <code>get_max_size()</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(name=\"value\", elements=((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record\nRecord(\n  (name): value\n  (max_size): 10\n  (record): ((None, 64.0), (None, 42.0))\n)\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n</code></pre>"},{"location":"refs/root/#minrecord.Record.max_size","title":"minrecord.Record.max_size  <code>property</code>","text":"<pre><code>max_size: int\n</code></pre> <p><code>int</code>: The maximum size of the record.</p>"},{"location":"refs/root/#minrecord.get_best_values","title":"minrecord.get_best_values","text":"<pre><code>get_best_values(\n    records: Mapping[str, BaseRecord],\n    prefix: str = \"\",\n    suffix: str = \"\",\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the best value of each record.</p> <p>This function ignores the empty and non-comparable records.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Mapping[str, BaseRecord]</code> <p>The records and their associated keys.</p> required <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import (\n...     MinScalarRecord,\n...     MaxScalarRecord,\n...     get_best_values,\n... )\n&gt;&gt;&gt; record1 = MinScalarRecord.from_elements(\"loss\", elements=[(None, 1.9), (None, 1.2)])\n&gt;&gt;&gt; record2 = MaxScalarRecord.from_elements(\"accuracy\", elements=[(None, 42), (None, 35)])\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2})\n{'loss': 1.2, 'accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, prefix=\"best/\")\n{'best/loss': 1.2, 'best/accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, suffix=\"/best\")\n{'loss/best': 1.2, 'accuracy/best': 42}\n</code></pre>"},{"location":"refs/root/#minrecord.get_last_values","title":"minrecord.get_last_values","text":"<pre><code>get_last_values(\n    records: Mapping[str, BaseRecord],\n    prefix: str = \"\",\n    suffix: str = \"\",\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the last value of each record.</p> <p>This function ignores the empty records.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Mapping[str, BaseRecord]</code> <p>The records and their associated keys.</p> required <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import (\n...     MinScalarRecord,\n...     MaxScalarRecord,\n...     get_best_values,\n... )\n&gt;&gt;&gt; record1 = MinScalarRecord.from_elements(\"loss\", elements=[(None, 1.9), (None, 1.2)])\n&gt;&gt;&gt; record2 = MaxScalarRecord.from_elements(\"accuracy\", elements=[(None, 42), (None, 35)])\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2})\n{'loss': 1.2, 'accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, prefix=\"best/\")\n{'best/loss': 1.2, 'best/accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, suffix=\"/best\")\n{'loss/best': 1.2, 'accuracy/best': 42}\n</code></pre>"},{"location":"refs/root/#minrecord.get_max_size","title":"minrecord.get_max_size","text":"<pre><code>get_max_size() -&gt; int\n</code></pre> <p>Get the current default maximum size of values to track in each record.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current default maximum size of values to track in each record.</p> <p>This value can be changed by using <code>set_max_size</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import get_max_size\n&gt;&gt;&gt; get_max_size()\n10\n</code></pre>"},{"location":"refs/root/#minrecord.set_max_size","title":"minrecord.set_max_size","text":"<pre><code>set_max_size(max_size: int) -&gt; None\n</code></pre> <p>Set the default maximum size of values to track in each record.</p> <p>This function does not change the maximum size of records that are already created. It only changes the maximum size of records that will be created after the call of this function.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>The new default maximum size of values to track in each record.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import get_max_size, set_max_size\n&gt;&gt;&gt; get_max_size()\n10\n&gt;&gt;&gt; set_max_size(5)\n&gt;&gt;&gt; get_max_size()\n5\n</code></pre>"},{"location":"refs/utils/","title":"minrecord.utils","text":""},{"location":"refs/utils/#minrecord.utils","title":"minrecord.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#minrecord.utils.value","title":"minrecord.utils.value","text":"<p>Contain utility functions to manage objects.</p>"},{"location":"refs/utils/#minrecord.utils.value.MutableValue","title":"minrecord.utils.value.MutableValue","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Implement a simple class to build a mutable object.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The initial value.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord.utils.value import MutableValue\n&gt;&gt;&gt; value = MutableValue(10)\n&gt;&gt;&gt; value.get_value()\n10\n&gt;&gt;&gt; value.set_value(42)\n&gt;&gt;&gt; value.get_value()\n42\n</code></pre>"},{"location":"refs/utils/#minrecord.utils.value.MutableValue.get_value","title":"minrecord.utils.value.MutableValue.get_value","text":"<pre><code>get_value() -&gt; T\n</code></pre> <p>Get the current value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value.</p>"},{"location":"refs/utils/#minrecord.utils.value.MutableValue.set_value","title":"minrecord.utils.value.MutableValue.set_value","text":"<pre><code>set_value(value: T) -&gt; None\n</code></pre> <p>Set a new value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The new value.</p> required"}]}