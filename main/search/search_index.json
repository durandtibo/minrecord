{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>minrecord</code> is a minimalist Python library to record values in a ML workflow. In particular, it provides functionalities to track the best value, or the most recent values by storing a limiting number of values. It is possible to customize the library e.g. it is possible to define a new logic to track the best value.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udcca Track Best Values: Automatically track the best value seen during training</li> <li>\ud83d\udd04 Recent History: Store only recent values to minimize memory usage</li> <li>\u2705 Improvement Detection: Easily check if your model is still improving</li> <li>\ud83c\udfaf Flexible Comparators: Define custom logic to determine what \"better\" means</li> <li>\ud83d\uddc2\ufe0f Record Manager: Organize and manage multiple metrics efficiently</li> <li>\ud83d\udcbe Serialization: Save and load record states for checkpointing</li> <li>\ud83d\ude80 Minimal Dependencies: Lightweight with only essential dependencies</li> </ul> <p>Below is an example to show how to track the best scalar value when the best value is the maximum value and when the best value is the minimum value.</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord, MinScalarRecord\n&gt;&gt;&gt; record_max = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record_max.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record_max.add_value(40)\n&gt;&gt;&gt; record_max.get_best_value()\n46\n&gt;&gt;&gt; record_min = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record_min.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record_min.add_value(50)\n&gt;&gt;&gt; record_min.get_best_value()\n42\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Get Started: Installation instructions</li> <li>Quickstart: Quick overview of the main features</li> <li>Usage Guide: Detailed patterns and best practices</li> <li>FAQ: Frequently asked questions and troubleshooting</li> <li>Migration Guide: Guide for upgrading between versions</li> <li>Examples: Complete working examples</li> <li>API Reference: Detailed API documentation</li> </ul>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>minrecord</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>minrecord</code> to a new version will possibly break any code that was using the old version of <code>minrecord</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>minrecord</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-minrecord","title":"What is minrecord?","text":"<p><code>minrecord</code> is a minimalist Python library designed to record and track values in machine learning workflows. It helps you track the best values, monitor recent metrics, and determine if your models are improving.</p>"},{"location":"faq/#why-use-minrecord-instead-of-storing-values-in-a-list","title":"Why use minrecord instead of storing values in a list?","text":"<p>While you can use a list, <code>minrecord</code> provides:</p> <ul> <li>Memory efficiency: Only stores recent values (configurable)</li> <li>Best value tracking: Automatically tracks the best value even if it's no longer in the recent   history</li> <li>Improvement detection: Easy to check if the latest value improved</li> <li>Structured management: RecordManager helps organize multiple metrics</li> <li>Serialization: Built-in support for saving/loading state</li> </ul>"},{"location":"faq/#is-minrecord-only-for-machine-learning","title":"Is minrecord only for machine learning?","text":"<p>No! While designed with ML in mind, <code>minrecord</code> can be used anywhere you need to track:</p> <ul> <li>Best values over time</li> <li>Recent measurements</li> <li>Whether metrics are improving</li> </ul>"},{"location":"faq/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"faq/#how-do-i-install-minrecord","title":"How do I install minrecord?","text":"<pre><code>pip install minrecord\n</code></pre> <p>For all optional dependencies:</p> <pre><code>pip install minrecord[all]\n</code></pre>"},{"location":"faq/#what-python-versions-are-supported","title":"What Python versions are supported?","text":"<p>Python 3.10 and higher are officially supported.</p>"},{"location":"faq/#do-i-need-pytorch-or-other-ml-frameworks","title":"Do I need PyTorch or other ML frameworks?","text":"<p>No, <code>minrecord</code> has minimal dependencies. It only requires <code>coola</code>, which is used for equality testing.</p>"},{"location":"faq/#usage-questions","title":"Usage Questions","text":""},{"location":"faq/#when-should-i-use-record-vs-comparablerecord","title":"When should I use Record vs ComparableRecord?","text":"<ul> <li>Use <code>Record</code> when you only need to track recent values</li> <li>Use <code>ComparableRecord</code>/<code>MinScalarRecord</code>/<code>MaxScalarRecord</code> when you need to:<ul> <li>Track the best value</li> <li>Check if values are improving</li> <li>Implement early stopping</li> </ul> </li> </ul>"},{"location":"faq/#how-do-i-choose-max_size","title":"How do I choose max_size?","text":"<p>Consider:</p> <ul> <li>Small values (10-50): For simple monitoring during training</li> <li>Large values (100-1000): For detailed analysis or plotting trends</li> <li>Memory constraints: Larger max_size \u00d7 number of records \u00d7 value size</li> </ul> <p>Default is 10, which works well for most ML training scenarios.</p>"},{"location":"faq/#can-i-change-max_size-after-creating-a-record","title":"Can I change max_size after creating a record?","text":"<p>No, <code>max_size</code> is fixed at creation. If you need to change it:</p> <ol> <li>Create a new record with the desired <code>max_size</code></li> <li>Optionally transfer values using <code>update(old_record.get_most_recent())</code></li> </ol>"},{"location":"faq/#what-happens-when-the-record-is-full","title":"What happens when the record is full?","text":"<p>The oldest value is automatically removed when adding a new value. The record uses a <code>deque</code> internally with a fixed maximum length.</p>"},{"location":"faq/#why-does-comparablerecord-constructor-behave-differently","title":"Why does ComparableRecord constructor behave differently?","text":"<p>If you pass <code>elements</code> to <code>ComparableRecord</code>, you must also pass <code>best_value</code> and <code>improved</code> to maintain correctness. This is because the best value might not be in the recent history.</p> <p>Recommended approach:</p> <pre><code># Good: Use from_elements\nrecord = MinScalarRecord.from_elements(\"loss\", [(0, 1.5), (1, 1.3)])\n\n# Or: Add values after creation\nrecord = MinScalarRecord(\"loss\")\nrecord.update([(0, 1.5), (1, 1.3)])\n\n# Avoid: Passing elements to constructor without best_value\nrecord = MinScalarRecord(\"loss\", elements=[(0, 1.5), (1, 1.3)])  # \u26a0\ufe0f\n</code></pre>"},{"location":"faq/#comparators-improvements","title":"Comparators &amp; Improvements","text":""},{"location":"faq/#how-does-has_improved-work","title":"How does has_improved() work?","text":"<p><code>has_improved()</code> returns <code>True</code> if the last added value is equal to or better than the best value seen so far.</p> <pre><code>record = MinScalarRecord(\"loss\")\nrecord.add_value(1.5)\nrecord.has_improved()  # True (first value is always improvement)\n\nrecord.add_value(1.3)\nrecord.has_improved()  # True (1.3 &lt; 1.5)\n\nrecord.add_value(1.4)\nrecord.has_improved()  # False (1.4 &gt; 1.3)\n</code></pre>"},{"location":"faq/#why-does-has_improved-return-true-for-equal-values","title":"Why does has_improved() return True for equal values?","text":"<p>By design, equal values are considered improvements. This is useful when a metric plateaus at the optimal value.</p>"},{"location":"faq/#can-i-create-custom-comparators","title":"Can I create custom comparators?","text":"<p>Yes! Implement <code>BaseComparator</code>:</p> <pre><code>from minrecord.comparator import BaseComparator\n\n\nclass MyComparator(BaseComparator[float]):\n    def equal(self, other: object) -&gt; bool:\n        return isinstance(other, self.__class__)\n\n    def get_initial_best_value(self) -&gt; float:\n        return 0.0  # Starting point\n\n    def is_better(self, old_value: float, new_value: float) -&gt; bool:\n        # Define your comparison logic\n        return new_value &gt; old_value\n</code></pre>"},{"location":"faq/#recordmanager-questions","title":"RecordManager Questions","text":""},{"location":"faq/#whats-the-benefit-of-recordmanager","title":"What's the benefit of RecordManager?","text":"<p>RecordManager provides:</p> <ul> <li>Organized storage: All records in one place</li> <li>Batch updates: Update multiple records at once</li> <li>Convenience methods: <code>get_best_values()</code>, <code>get_last_values()</code></li> <li>State management: Save/load all records together</li> </ul>"},{"location":"faq/#does-recordmanager-create-records-automatically","title":"Does RecordManager create records automatically?","text":"<p>Yes, <code>get_record()</code> creates a default <code>Record</code> if the name doesn't exist:</p> <pre><code>manager = RecordManager()\nrecord = manager.get_record(\"new_metric\")  # Auto-created\n</code></pre> <p>To check if a record exists first:</p> <pre><code>if manager.has_record(\"my_metric\"):\n    record = manager.get_record(\"my_metric\")\n</code></pre>"},{"location":"faq/#can-i-use-different-record-types-in-the-same-manager","title":"Can I use different record types in the same manager?","text":"<p>Yes! RecordManager accepts any <code>BaseRecord</code> implementation:</p> <pre><code>manager = RecordManager()\nmanager.add_record(MinScalarRecord(\"loss\"))\nmanager.add_record(MaxScalarRecord(\"accuracy\"))\nmanager.add_record(Record(\"custom_metric\"))\n</code></pre>"},{"location":"faq/#error-handling","title":"Error Handling","text":""},{"location":"faq/#what-is-emptyrecorderror","title":"What is EmptyRecordError?","text":"<p>This error occurs when you try to get a value from an empty record:</p> <pre><code>record = Record(\"my_metric\")\n# record.get_last_value()  # Raises EmptyRecordError\n\n# Check first\nif not record.is_empty():\n    value = record.get_last_value()\n</code></pre>"},{"location":"faq/#what-is-notacomparablerecorderror","title":"What is NotAComparableRecordError?","text":"<p>This error occurs when you call comparison methods on a non-comparable record:</p> <pre><code>record = Record(\"my_metric\")  # Not comparable\n# record.get_best_value()  # Raises NotAComparableRecordError\n\n# Use is_comparable() to check\nif record.is_comparable():\n    best = record.get_best_value()\n</code></pre>"},{"location":"faq/#performance-scalability","title":"Performance &amp; Scalability","text":""},{"location":"faq/#how-many-records-can-i-have","title":"How many records can I have?","text":"<p>There's no hard limit. Each record has minimal overhead. With max_size=10:</p> <ul> <li>Memory per record: ~200-500 bytes + stored values</li> <li>1000 records with scalars: ~1-2 MB</li> </ul>"},{"location":"faq/#is-minrecord-thread-safe","title":"Is minrecord thread-safe?","text":"<p>No, records are not thread-safe. If using multiple threads:</p> <ul> <li>Use separate records per thread, or</li> <li>Implement your own locking mechanism</li> </ul>"},{"location":"faq/#can-i-use-minrecord-in-distributed-training","title":"Can I use minrecord in distributed training?","text":"<p>Yes, but each process needs its own records. After training:</p> <ul> <li>Gather metrics from all processes</li> <li>Aggregate as needed for logging</li> </ul>"},{"location":"faq/#integration-questions","title":"Integration Questions","text":""},{"location":"faq/#how-do-i-integrate-with-tensorboard","title":"How do I integrate with TensorBoard?","text":"<pre><code>from torch.utils.tensorboard import SummaryWriter\nfrom minrecord import RecordManager\n\nwriter = SummaryWriter()\nmanager = RecordManager()\n\nfor epoch in range(epochs):\n    # Training...\n    # Add values to records\n    for name, value in metrics.items():\n        manager.get_record(name).add_value(value, step=epoch)\n\n    # Log to TensorBoard\n    for name in manager.get_records().keys():\n        record = manager.get_record(name)\n        if not record.is_empty():\n            writer.add_scalar(name, record.get_last_value(), epoch)\n</code></pre>"},{"location":"faq/#how-do-i-integrate-with-weights-biases-wandb","title":"How do I integrate with Weights &amp; Biases (wandb)?","text":"<pre><code>import wandb\nfrom minrecord import RecordManager\n\nwandb.init(project=\"my-project\")\nmanager = RecordManager()\n\nfor epoch in range(epochs):\n    # Training...\n    # Add values to records\n    for name, value in metrics.items():\n        manager.get_record(name).add_value(value, step=epoch)\n\n    wandb.log(\n        {\n            \"epoch\": epoch,\n            **manager.get_last_values(prefix=\"train/\"),\n            **manager.get_best_values(prefix=\"best/\"),\n        }\n    )\n</code></pre>"},{"location":"faq/#does-minrecord-work-with-pytorch-lightning","title":"Does minrecord work with PyTorch Lightning?","text":"<p>Yes! Use records in your LightningModule:</p> <pre><code>import pytorch_lightning as pl\nfrom minrecord import MinScalarRecord\n\n\nclass MyModel(pl.LightningModule):\n    def __init__(self):\n        super().__init__()\n        self.val_loss = MinScalarRecord(\"val_loss\")\n\n    def validation_epoch_end(self, outputs):\n        avg_loss = torch.stack([x[\"loss\"] for x in outputs]).mean()\n        self.val_loss.add_value(avg_loss.item(), step=self.current_epoch)\n\n        if self.val_loss.has_improved():\n            self.save_checkpoint(\"best_model.ckpt\")\n</code></pre>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#values-seem-incorrect-after-loading-state","title":"Values seem incorrect after loading state","text":"<p>Make sure to use <code>from_elements()</code> or properly initialize <code>best_value</code>:</p> <pre><code># Correct\nrecord = MinScalarRecord.from_elements(\"loss\", elements)\n\n# Also correct\nrecord = MinScalarRecord(\"loss\")\nrecord.update(elements)\n</code></pre>"},{"location":"faq/#get_best_values-returns-fewer-items-than-expected","title":"get_best_values() returns fewer items than expected","text":"<p><code>get_best_values()</code> only returns values for:</p> <ul> <li>Non-empty records</li> <li>Comparable records</li> </ul> <p>Use <code>get_last_values()</code> for all records:</p> <pre><code>last_values = manager.get_last_values()  # All non-empty records\nbest_values = manager.get_best_values()  # Only comparable records\n</code></pre>"},{"location":"faq/#record-not-found-errors","title":"Record not found errors","text":"<p>Check that record names match exactly:</p> <pre><code>manager.add_record(MinScalarRecord(\"train/loss\"))  # Note the \"/\"\n# Wrong name:\nmanager.get_record(\"train_loss\").add_value(1.5, step=0)  # KeyError if not auto-created\n# Correct:\nmanager.get_record(\"train/loss\").add_value(1.5, step=0)\n</code></pre>"},{"location":"faq/#need-more-help","title":"Need More Help?","text":"<ul> <li>Check the Usage Guide for detailed patterns</li> <li>See Examples for complete code</li> <li>Open an Issue on GitHub</li> <li>Read the API Reference for detailed documentation</li> </ul>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-or-uv-pip-recommended","title":"Installing with <code>pip</code> or <code>uv pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code># pip\npip install minrecord\n\n# uv\nuv pip install minrecord\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>minrecord</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code># pip\npip install 'minrecord[all]'\n\n# uv\nuv pip install 'minrecord[all]'\n</code></pre> <p>This command also installed NumPy and PyTorch. It is also possible to install the optional packages manually or to select the packages to install. In the following example, only NumPy is installed:</p> <pre><code>pip install minrecord numpy\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>minrecord</code> from source, you can follow the steps below. First, you will need to install <code>uv</code>. <code>uv</code> is used to manage and install the dependencies. If <code>uv</code> is already installed on your machine, you can skip this step. You can install <code>uv</code> by running:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>You can check the <code>uv</code> installation by running the following command:</p> <pre><code>uv --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/minrecord.git\ncd minrecord\n</code></pre> <p>It is recommended to create a Python 3.10+ virtual environment. This step is optional so you can skip it. You can use <code>uv</code> to create a virtual environment:</p> <pre><code>make setup-venv\nsource .venv/bin/activate\n</code></pre> <p>This example uses <code>uv</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>minrecord</code> with the following command:</p> <pre><code>inv install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>inv unit-test --cov\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p> This page gives a quick overview on how to use the <code>minrecord</code>. You should read this page if you want to learn how to use the records. This page does not explain the internal behavior of the records. While <code>minrecord</code> was designed to work in a ML workflow, you can use it in other contexts if it fits your need.</p> <p>Prerequisites: You\u2019ll need to know a bit of Python. For a refresher, see the Python tutorial.</p>"},{"location":"quickstart/#record","title":"Record","text":"<p><code>minrecord</code> is organized around the <code>BaseRecord</code> class. It defines the interface to implement a record object. <code>minrecord</code> provides the <code>Record</code> class, which is a generic implementation of a record. Each <code>Record</code> object has a name and tracks the last values.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=0)\n&gt;&gt;&gt; record.name\n'loss'\n</code></pre> <p>Usually, it is useful to keep only the last values, but it also possible to track a large number of values, but it can consume a lot of memory of the values to track take significant amount of memory. By default, the <code>Record</code> objects only track the last 10 values, but it is possible to control the memory consumption by setting carefully the <code>max_size</code> argument.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"my_record\", max_size=5)\n&gt;&gt;&gt; record\nRecord(name=my_record, max_size=5, size=0)\n</code></pre> <p>After creating a record, the <code>add_record</code> method can be used to add a value to the record. The following example shows how to add the value <code>4.2</code> to the record.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(4.2)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=1)\n</code></pre> <p>When adding a value, it is possible to specify a step to track when the value was added.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(4.2, step=2)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=1)\n</code></pre> <p>The step can be a number or <code>None</code>. <code>None</code> means no valid step to track. It is possible to get the last value added by using the <code>get_best_value</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(4.2, step=1)\n&gt;&gt;&gt; record.add_value(2.4, step=2)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=2)\n&gt;&gt;&gt; record.get_last_value()\n2.4\n</code></pre> <p>Calling <code>get_best_value</code> on an empty record raises a <code>EmptyRecordError</code> exception. It is possible to check if a record is empty or not by using the <code>is_empty</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_empty()\nTrue\n&gt;&gt;&gt; record.add_value(4.2, step=1)\n&gt;&gt;&gt; record.is_empty()\nFalse\n</code></pre> <p>If there are multiple values to add, it is possible to use the <code>update</code> method. The input is a sequence of 2-tuples where the first item is the step and the second item is the value.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=3)\n&gt;&gt;&gt; record.get_last_value()\n46\n</code></pre> <p>In the example above, the second element does not have a valid step so the value is set to <code>None</code>. It is possible to add elements when creating the record.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=3)\n&gt;&gt;&gt; record.get_last_value()\n46\n</code></pre> <p>It is possible to access the most recent values added to the record by using the <code>get_most_recent</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(40)\n&gt;&gt;&gt; record.get_most_recent()\n((0, 42), (None, 45), (2, 46), (None, 40))\n</code></pre> <p>It is possible to check if two <code>Record</code> objects are equal by calling the <code>equal</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record1 = Record(\"loss\")\n&gt;&gt;&gt; record2 = Record(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record3 = Record(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record1.equal(record2)\nFalse\n&gt;&gt;&gt; record3.equal(record2)\nTrue\n</code></pre>"},{"location":"quickstart/#comparable-record","title":"Comparable Record","text":"<p><code>minrecord</code> also provides some comparable records i.e. records that track the best value. There is a generic <code>ComparableRecord</code> class where the user just needs to implement the comparator object that is used to find the nest value. There are <code>MaxScalarRecord</code> and <code>MinScalarRecord</code> that are specialized implementations of <code>ComparableRecord</code> for scalars (e.g. <code>float</code> or <code>int</code>). It is possible to know if a record is comparable by calling the <code>is_comparable</code> methods.</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord, MinScalarRecord, Record\n&gt;&gt;&gt; record = Record(\"my_value\")\n&gt;&gt;&gt; record.is_comparable()\nFalse\n&gt;&gt;&gt; record_max = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record_max.is_comparable()\nTrue\n&gt;&gt;&gt; record_min = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record_min.is_comparable()\nTrue\n</code></pre> <p>These records support the <code>Record</code> functionalities, and additional functionalities. It is possible to use the <code>get_best_value</code> method to get the best value.</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord, MinScalarRecord\n&gt;&gt;&gt; record_max = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record_max.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record_max.add_value(40)\n&gt;&gt;&gt; record_max.get_best_value()\n46\n&gt;&gt;&gt; record_min = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record_min.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record_min.add_value(50)\n&gt;&gt;&gt; record_min.get_best_value()\n42\n</code></pre> <p>The record tracks the best value even if the best value is not store in the record. Below is an example where the record's maximum size is set to 3.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\", max_size=3)\n&gt;&gt;&gt; record.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.add_value(60)\n&gt;&gt;&gt; record.get_most_recent()\n((2, 46), (None, 50), (None, 60))\n&gt;&gt;&gt; record.get_best_value()\n42\n</code></pre> <p>Calling <code>get_best_value</code> on an empty record raises an <code>EmptyRecordError</code> exception. It is possible to know if the last value added improved the best value or not by calling the <code>has_improved</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.has_improved()\nTrue\n&gt;&gt;&gt; record.add_value(60)\n&gt;&gt;&gt; record.has_improved()\nFalse\n&gt;&gt;&gt; record.add_value(42)\n&gt;&gt;&gt; record.has_improved()\nTrue\n&gt;&gt;&gt; record.add_value(43)\n&gt;&gt;&gt; record.has_improved()\nFalse\n</code></pre> <p>By definition, <code>has_improved</code> will return <code>True</code> if the last value is equal to the best value as shown in the example below.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record.add_value(42)\n&gt;&gt;&gt; record.has_improved()\nTrue\n&gt;&gt;&gt; record.add_value(42)\n&gt;&gt;&gt; record.has_improved()\nTrue\n</code></pre> <p> Calling <code>has_improved</code> or <code>get_best_value</code> on non-comparable record raises a <code>NotAComparableRecord</code> exception.</p> <p> Note about constructors: the constructor of <code>ComparableRecord</code> works slightly differently from <code>Record</code>. If you pass some elements to the constructor, you also need to pass the <code>best_value</code> and <code>improved</code> arguments to have the correct behavior. It is not a mistake but the expected behavior as the best value can be outside of the values store in the record.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; # Incorrect behavior\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.get_best_value()\n50\n&gt;&gt;&gt; # Correct behavior\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.get_best_value()\n42\n</code></pre> <p>To automatically instantiate the record based on the input elements, you can use the <code>from_elements</code> class method.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord.from_elements(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.get_best_value()\n42\n</code></pre>"},{"location":"quickstart/#record-manager","title":"Record Manager","text":"<p>When working with multiple records, <code>RecordManager</code> provides a convenient way to organize and manage them. It allows you to add, update, and query multiple records efficiently.</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord, MaxScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.add_record(MaxScalarRecord(\"accuracy\"))\n&gt;&gt;&gt; manager\nRecordManager(\n  (loss): MinScalarRecord(name=loss, max_size=10, size=0)\n  (accuracy): MaxScalarRecord(name=accuracy, max_size=10, size=0)\n)\n</code></pre> <p>You can update multiple records at once:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord, MaxScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.add_record(MaxScalarRecord(\"accuracy\"))\n&gt;&gt;&gt; manager.get_record(\"loss\").add_value(1.5, step=0)\n&gt;&gt;&gt; manager.get_record(\"accuracy\").add_value(0.85, step=0)\n&gt;&gt;&gt; manager.get_record(\"loss\").add_value(1.3, step=1)\n&gt;&gt;&gt; manager.get_record(\"accuracy\").add_value(0.87, step=1)\n&gt;&gt;&gt; manager.get_record(\"loss\").get_best_value()\n1.3\n&gt;&gt;&gt; manager.get_record(\"accuracy\").get_best_value()\n0.87\n</code></pre> <p>The manager provides convenient methods to get all best or last values:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord, MaxScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.add_record(MaxScalarRecord(\"accuracy\"))\n&gt;&gt;&gt; manager.get_record(\"loss\").add_value(1.5, step=0)\n&gt;&gt;&gt; manager.get_record(\"accuracy\").add_value(0.85, step=0)\n&gt;&gt;&gt; manager.get_record(\"loss\").add_value(1.3, step=1)\n&gt;&gt;&gt; manager.get_record(\"accuracy\").add_value(0.87, step=1)\n&gt;&gt;&gt; manager.get_best_values()\n{'loss': 1.3, 'accuracy': 0.87}\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can:</p> <ul> <li>Read the Usage Guide for detailed patterns and best practices</li> <li>Explore Examples for complete working code</li> <li>Check the FAQ for common questions and troubleshooting</li> <li>Browse the API Reference for detailed documentation</li> </ul>"},{"location":"usage_guide/","title":"Usage Guide","text":"<p>This guide provides practical information for using <code>minrecord</code> effectively in your projects.</p>"},{"location":"usage_guide/#when-to-use-minrecord","title":"When to Use minrecord","text":"<p><code>minrecord</code> is designed for scenarios where you need to:</p> <ul> <li>Track the best value achieved during training (e.g., best validation accuracy)</li> <li>Monitor recent values without storing the entire history</li> <li>Manage multiple metrics in a structured way</li> <li>Determine if your model is still improving</li> <li>Implement early stopping based on metric improvements</li> </ul>"},{"location":"usage_guide/#core-concepts","title":"Core Concepts","text":""},{"location":"usage_guide/#records-vs-comparable-records","title":"Records vs Comparable Records","text":"<p>Records (<code>Record</code>) are the basic building blocks that store recent values:</p> <ul> <li>Store a configurable number of recent values</li> <li>Provide access to the most recent value</li> <li>Don't track \"best\" values</li> </ul> <p>Comparable Records (<code>ComparableRecord</code>, <code>MinScalarRecord</code>, <code>MaxScalarRecord</code>) extend records with comparison logic:</p> <ul> <li>Track the best value seen so far</li> <li>Indicate whether the latest value is an improvement</li> <li>Use comparators to define what \"better\" means</li> </ul>"},{"location":"usage_guide/#memory-management","title":"Memory Management","text":"<p>By default, records keep only the last 10 values. This is configurable:</p> <pre><code>from minrecord import Record, get_max_size, set_max_size\n\n# Check default\nprint(get_max_size())  # 10\n\n# Change globally for new records\nset_max_size(20)\n\n# Or set per record\nrecord = Record(\"my_metric\", max_size=50)\n</code></pre> <p>Why limit stored values?</p> <ul> <li>Reduces memory footprint in long-running training jobs</li> <li>Best values are tracked separately and never lost</li> <li>Recent values are usually sufficient for monitoring</li> </ul>"},{"location":"usage_guide/#common-patterns","title":"Common Patterns","text":""},{"location":"usage_guide/#pattern-1-basic-training-loop","title":"Pattern 1: Basic Training Loop","text":"<pre><code>from minrecord import MinScalarRecord, MaxScalarRecord\n\ntrain_loss = MinScalarRecord(\"train_loss\")\nval_accuracy = MaxScalarRecord(\"val_accuracy\")\n\nfor epoch in range(num_epochs):\n    # Training...\n    train_loss.add_value(epoch_loss, step=epoch)\n    val_accuracy.add_value(epoch_acc, step=epoch)\n\n    if val_accuracy.has_improved():\n        save_checkpoint(model, \"best_model.pt\")\n</code></pre>"},{"location":"usage_guide/#pattern-2-managing-multiple-metrics","title":"Pattern 2: Managing Multiple Metrics","text":"<pre><code>from minrecord import RecordManager, MinScalarRecord, MaxScalarRecord\n\nmanager = RecordManager()\nmanager.add_record(MinScalarRecord(\"train/loss\"))\nmanager.add_record(MinScalarRecord(\"val/loss\"))\nmanager.add_record(MaxScalarRecord(\"train/accuracy\"))\nmanager.add_record(MaxScalarRecord(\"val/accuracy\"))\n\n# Add values to each record\nmanager.get_record(\"train/loss\").add_value(train_loss, step=epoch)\nmanager.get_record(\"val/loss\").add_value(val_loss, step=epoch)\nmanager.get_record(\"train/accuracy\").add_value(train_acc, step=epoch)\nmanager.get_record(\"val/accuracy\").add_value(val_acc, step=epoch)\n\n# Get best values for logging\nbest_values = manager.get_best_values()\n</code></pre>"},{"location":"usage_guide/#pattern-3-early-stopping","title":"Pattern 3: Early Stopping","text":"<pre><code>from minrecord import MinScalarRecord\n\nval_loss = MinScalarRecord(\"val_loss\")\npatience = 5\nno_improvement_count = 0\n\nfor epoch in range(num_epochs):\n    # Training...\n    val_loss.add_value(epoch_val_loss, step=epoch)\n\n    if val_loss.has_improved():\n        no_improvement_count = 0\n        save_checkpoint(model, \"best_model.pt\")\n    else:\n        no_improvement_count += 1\n\n    if no_improvement_count &gt;= patience:\n        print(f\"Early stopping at epoch {epoch}\")\n        break\n</code></pre>"},{"location":"usage_guide/#pattern-4-custom-comparators","title":"Pattern 4: Custom Comparators","text":"<p>For specialized metrics, create custom comparators:</p> <pre><code>from minrecord import ComparableRecord\nfrom minrecord.comparator import BaseComparator\n\n\nclass F1Comparator(BaseComparator[tuple[float, float]]):\n    \"\"\"Maximize F1 score from precision and recall.\"\"\"\n\n    def equal(self, other: object) -&gt; bool:\n        return isinstance(other, self.__class__)\n\n    def get_initial_best_value(self) -&gt; tuple[float, float]:\n        return (0.0, 0.0)\n\n    def is_better(\n        self, old_value: tuple[float, float], new_value: tuple[float, float]\n    ) -&gt; bool:\n        def f1(p, r):\n            return 2 * p * r / (p + r) if (p + r) &gt; 0 else 0\n\n        return f1(*new_value) &gt; f1(*old_value)\n\n\nrecord = ComparableRecord(\"f1_components\", F1Comparator())\nrecord.add_value((precision, recall))\n</code></pre>"},{"location":"usage_guide/#performance-considerations","title":"Performance Considerations","text":""},{"location":"usage_guide/#memory-usage","title":"Memory Usage","text":"<ul> <li>Each record stores a fixed number of values (default 10)</li> <li>Use <code>max_size</code> appropriately for your use case</li> <li>Consider the size of each value (e.g., scalars vs large objects)</li> </ul>"},{"location":"usage_guide/#computational-cost","title":"Computational Cost","text":"<ul> <li>Adding values is O(1) (deque append)</li> <li>Getting best/last values is O(1)</li> <li>Comparison operations depend on the comparator implementation</li> </ul>"},{"location":"usage_guide/#best-practices","title":"Best Practices","text":"<ol> <li>Set appropriate max_size: Balance between memory and information needs</li> <li>Use RecordManager for multiple metrics to keep code organized</li> <li>Reuse records across training runs by loading/saving state</li> <li>Avoid storing large objects: Records are meant for scalars or small objects</li> </ol>"},{"location":"usage_guide/#integration-with-ml-frameworks","title":"Integration with ML Frameworks","text":""},{"location":"usage_guide/#pytorch-example","title":"PyTorch Example","text":"<pre><code>import torch\nfrom minrecord import MinScalarRecord, MaxScalarRecord\n\ntrain_loss = MinScalarRecord(\"train_loss\")\nval_accuracy = MaxScalarRecord(\"val_accuracy\")\n\nfor epoch in range(epochs):\n    model.train()\n    epoch_loss = 0\n    for batch in train_loader:\n        loss = train_step(model, batch)\n        epoch_loss += loss.item()\n\n    train_loss.add_value(epoch_loss / len(train_loader), step=epoch)\n\n    model.eval()\n    with torch.no_grad():\n        acc = evaluate(model, val_loader)\n    val_accuracy.add_value(acc, step=epoch)\n\n    if val_accuracy.has_improved():\n        torch.save(model.state_dict(), \"best_model.pt\")\n</code></pre>"},{"location":"usage_guide/#logging-integration","title":"Logging Integration","text":"<pre><code>import wandb\nfrom minrecord import RecordManager\n\nmanager = RecordManager()\n# ... add records ...\n\nfor epoch in range(epochs):\n    # Training...\n    # Add values to records\n    for name, value in metrics.items():\n        manager.get_record(name).add_value(value, step=epoch)\n\n    # Log to wandb\n    wandb.log(\n        {\n            \"epoch\": epoch,\n            **manager.get_last_values(prefix=\"current/\"),\n            **manager.get_best_values(prefix=\"best/\"),\n        }\n    )\n</code></pre>"},{"location":"usage_guide/#state-management","title":"State Management","text":"<p>Records support serialization for checkpointing:</p> <pre><code># Save state\nstate = record.state_dict()\ntorch.save(state, \"record_state.pt\")\n\n# Load state\nstate = torch.load(\"record_state.pt\")\nrecord.load_state_dict(state)\n</code></pre> <p>For RecordManager:</p> <pre><code># Save entire manager\nmanager_state = manager.state_dict()\n\n# Load into new manager\nnew_manager = RecordManager()\nnew_manager.load_state_dict(manager_state)\n</code></pre>"},{"location":"usage_guide/#debugging-tips","title":"Debugging Tips","text":""},{"location":"usage_guide/#check-if-metrics-are-improving","title":"Check if metrics are improving","text":"<pre><code>record = MinScalarRecord(\"loss\")\nrecord.add_value(1.5)\nrecord.add_value(1.3)\nprint(f\"Has improved: {record.has_improved()}\")  # True\nprint(f\"Best value: {record.get_best_value()}\")  # 1.3\n</code></pre>"},{"location":"usage_guide/#inspect-recent-history","title":"Inspect recent history","text":"<pre><code>print(f\"Recent values: {record.get_most_recent()}\")\nprint(f\"Number of stored values: {len(record)}\")\n</code></pre>"},{"location":"usage_guide/#verify-record-equality","title":"Verify record equality","text":"<pre><code># Useful for testing\nrecord1 = MinScalarRecord.from_elements(\"loss\", [(0, 1.5), (1, 1.3)])\nrecord2 = MinScalarRecord.from_elements(\"loss\", [(0, 1.5), (1, 1.3)])\nassert record1.equal(record2)\n</code></pre>"},{"location":"usage_guide/#see-also","title":"See Also","text":"<ul> <li>Quickstart Guide for basic usage</li> <li>Examples for complete working examples</li> <li>FAQ for common questions and troubleshooting</li> <li>Migration Guide for upgrading between versions</li> <li>API Reference:</li> <li>minrecord - Main package</li> <li>minrecord.base - Base classes and exceptions</li> <li>minrecord.comparable - Comparable record implementations</li> <li>minrecord.comparator - Comparator classes</li> <li>minrecord.functional - Utility functions</li> <li>minrecord.generic - Generic record implementation</li> <li>minrecord.manager - Record manager</li> </ul>"},{"location":"refs/base/","title":"minrecord.base","text":""},{"location":"refs/base/#minrecord.base","title":"minrecord.base","text":"<p>Contain the base class to record values.</p>"},{"location":"refs/base/#minrecord.base.BaseRecord","title":"minrecord.base.BaseRecord","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a record.</p> <p>The record tracks the value added as well as the step when the value is added. The goal of this class is to track the recent record because the loggers (e.g. MLFlow or Tensorboard) do not allow to get the last value or the best value. The record keeps in memory a recent record of pairs (step, value) where step is the index of the step when the value was added. The length of the recent record depends on the concrete implementation.</p> <p>To implement your own record, you will need to define the following methods:</p> <pre><code>- ``add_value``\n- ``get_last_value``\n- ``get_most_recent``\n- ``is_comparable``\n- ``is_empty``\n- ``update``\n- ``load_state_dict``\n- ``state_dict``\n</code></pre> <p>If it is a comparable record, you will need to implement the following methods too:</p> <pre><code>- ``_get_best_value``\n- ``_has_improved``\n</code></pre> <p>You may also need to extend the <code>config_dict</code> method.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.get_last_value()\n1.2\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.name","title":"minrecord.base.BaseRecord.name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the record.</p>"},{"location":"refs/base/#minrecord.base.BaseRecord.add_value","title":"minrecord.base.BaseRecord.add_value  <code>abstractmethod</code>","text":"<pre><code>add_value(value: T, step: float | None = None) -&gt; None\n</code></pre> <p>Add a new value to the record.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to add to the record.</p> required <code>step</code> <code>float | None</code> <p>The step value to record. <code>None</code> means there is no step to track.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2)\n&gt;&gt;&gt; record.add_value(value=42, step=1)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=2)\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.clone","title":"minrecord.base.BaseRecord.clone  <code>abstractmethod</code>","text":"<pre><code>clone() -&gt; BaseRecord[T]\n</code></pre> <p>Clone the current record.</p> <p>Returns:</p> Type Description <code>BaseRecord[T]</code> <p>A copy of the current record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record_cloned = record.clone()\n&gt;&gt;&gt; record_cloned\nRecord(name=loss, max_size=10, size=0)\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.config_dict","title":"minrecord.base.BaseRecord.config_dict","text":"<pre><code>config_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get the config of the record.</p> <p>The config dictionary should contain all the values necessary to instantiate a record with the same parameters with the  <code>factory</code> method. It is expected to contain values like the full name of the class and the arguments of the constructor. This dictionary should not contain the state values. It is possible to get the state values with the <code>state_dict</code> method.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The config of the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord, Record\n&gt;&gt;&gt; config = Record(\"loss\").config_dict()\n&gt;&gt;&gt; record = BaseRecord.factory(**config)  # Note that the state is not copied.\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=0)\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.equal","title":"minrecord.base.BaseRecord.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two records are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the records are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record1 = Record(\"loss\")\n&gt;&gt;&gt; record2 = Record(\"accuracy\")\n&gt;&gt;&gt; record3 = Record(\"loss\")\n&gt;&gt;&gt; record1.equal(record2)\nFalse\n&gt;&gt;&gt; record1.equal(record1)\nTrue\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.from_dict","title":"minrecord.base.BaseRecord.from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; BaseRecord[T]\n</code></pre> <p>Instantiate a record from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The dictionary that is used to instantiate the record. The dictionary is expected to contain the parameters to create instantiate the record and the state of the record.</p> required <p>Returns:</p> Type Description <code>BaseRecord[T]</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord\n&gt;&gt;&gt; from objectory import OBJECT_TARGET\n&gt;&gt;&gt; record = BaseRecord.from_dict(\n...     {\n...         \"config\": {\n...             OBJECT_TARGET: \"minrecord.Record\",\n...             \"name\": \"loss\",\n...             \"max_size\": 7,\n...         },\n...         \"state\": {\"record\": ((0, 1), (1, 5))},\n...     }\n... )\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=7, size=2)\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.get_best_value","title":"minrecord.base.BaseRecord.get_best_value","text":"<pre><code>get_best_value() -&gt; T\n</code></pre> <p>Get the best value of this record.</p> <p>It is possible to get the best value only if it is a comparable record i.e. it is possible to compare the values in the record.</p> <p>Returns:</p> Type Description <code>T</code> <p>The best value of this record.</p> <p>Raises:</p> Type Description <code>NotAComparableRecord</code> <p>if it is not a comparable record.</p> <code>EmptyRecordError</code> <p>if the record is empty</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=4, step=1)\n&gt;&gt;&gt; record.get_best_value()\n4\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.get_last_value","title":"minrecord.base.BaseRecord.get_last_value  <code>abstractmethod</code>","text":"<pre><code>get_last_value() -&gt; T\n</code></pre> <p>Get the last value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The last value added in the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.get_last_value()\n1.2\n&gt;&gt;&gt; record.add_value(value=0.8, step=1)\n&gt;&gt;&gt; record.get_last_value()\n0.8\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.get_most_recent","title":"minrecord.base.BaseRecord.get_most_recent  <code>abstractmethod</code>","text":"<pre><code>get_most_recent() -&gt; tuple[tuple[float | None, T], ...]\n</code></pre> <p>Get the tuple of recent values and their associated steps.</p> <p>The last value in the tuple is the last value added to the record. The length of the recent record depends on the concrete implementation.</p> <p>Returns:</p> Type Description <code>tuple[tuple[float | None, T], ...]</code> <p>A tuple of the recent values in the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.add_value(value=0.8, step=2)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 2), (1, 1.2), (2, 0.8))\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.has_improved","title":"minrecord.base.BaseRecord.has_improved","text":"<pre><code>has_improved() -&gt; bool\n</code></pre> <p>Indicate if the last value is the best value.</p> <p>It is possible to use this method only if it is a comparable record i.e. it is possible to compare the values in the record.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the last value is the best value, otherwise <code>False</code>.</p> <p>Raises:</p> Type Description <code>NotAComparableRecord</code> <p>if it is not a comparable record.</p> <code>EmptyRecordError</code> <p>if the record is empty</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=4, step=1)\n&gt;&gt;&gt; record.has_improved()\nTrue\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.is_comparable","title":"minrecord.base.BaseRecord.is_comparable  <code>abstractmethod</code>","text":"<pre><code>is_comparable() -&gt; bool\n</code></pre> <p>Indicate if it is possible to compare the values in the record.</p> <p>Note that it is possible to compute the best value only for records that are comparable.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if it is possible to compare the values in the record, otherwise <code>False</code>.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_comparable()\nFalse\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.is_empty","title":"minrecord.base.BaseRecord.is_empty  <code>abstractmethod</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Indicate if the record is empty or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the record is empty, otherwise <code>False</code>.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_empty()\nTrue\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.load_state_dict","title":"minrecord.base.BaseRecord.load_state_dict  <code>abstractmethod</code>","text":"<pre><code>load_state_dict(state_dict: dict[str, Any]) -&gt; None\n</code></pre> <p>Set up the record from a dictionary containing the state values.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict[str, Any]</code> <p>A dictionary containing state keys with values.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.load_state_dict({\"record\": ((0, 42.0),)})\n&gt;&gt;&gt; record.get_last_value()\n42.0\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.state_dict","title":"minrecord.base.BaseRecord.state_dict  <code>abstractmethod</code>","text":"<pre><code>state_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get a dictionary containing the state values of the record.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The state values in a dict.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(42.0, step=0)\n&gt;&gt;&gt; state = record.state_dict()\n&gt;&gt;&gt; state\n{'record': ((0, 42.0),)}\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.to_dict","title":"minrecord.base.BaseRecord.to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Export the current record to a dictionary.</p> <p>This method exports all the information to re-create the record with the same state. The returned dictionary can be used as input of the <code>from_dict</code> method to resume the record.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with the config and the state of the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord, Record\n&gt;&gt;&gt; record_dict = Record(\"loss\").to_dict()\n&gt;&gt;&gt; record = BaseRecord.from_dict(record_dict)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=0)\n</code></pre>"},{"location":"refs/base/#minrecord.base.BaseRecord.update","title":"minrecord.base.BaseRecord.update  <code>abstractmethod</code>","text":"<pre><code>update(elements: Iterable[tuple[float | None, T]]) -&gt; None\n</code></pre> <p>Update the record by adding the elements.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The elements to add to the record.  Each tuple has the following structure <code>(step, value)</code>. The step can be <code>None</code> if there is no step.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.update([(0, 42), (1, 45)])\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=2)\n</code></pre>"},{"location":"refs/base/#minrecord.base.EmptyRecordError","title":"minrecord.base.EmptyRecordError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise an error if the record is empty.</p>"},{"location":"refs/base/#minrecord.base.NotAComparableRecordError","title":"minrecord.base.NotAComparableRecordError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise an error if it is not possible to compare the values in the record.</p>"},{"location":"refs/base/#minrecord.base.RecordEqualityComparator","title":"minrecord.base.RecordEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[BaseRecord]</code></p> <p>Implement an equality comparator for <code>BaseRecord</code> objects.</p>"},{"location":"refs/comparable/","title":"minrecord.comparable","text":""},{"location":"refs/comparable/#minrecord.comparable","title":"minrecord.comparable","text":"<p>Contain the comparable record implementations.</p>"},{"location":"refs/comparable/#minrecord.comparable.ComparableRecord","title":"minrecord.comparable.ComparableRecord","text":"<p>               Bases: <code>Record[T]</code></p> <p>Implement a record of comparable values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>comparator</code> <code>BaseComparator[T]</code> <p>The comparator to use to find the best value.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store in the record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import ComparableRecord\n&gt;&gt;&gt; from minrecord.comparator import MaxScalarComparator\n&gt;&gt;&gt; record = ComparableRecord(\"value\", MaxScalarComparator())\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/comparable/#minrecord.comparable.ComparableRecord.is_better","title":"minrecord.comparable.ComparableRecord.is_better","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import ComparableRecord\n&gt;&gt;&gt; from minrecord.comparator import MaxScalarComparator\n&gt;&gt;&gt; record = ComparableRecord(\"accuracy\", MaxScalarComparator())\n&gt;&gt;&gt; record.is_better(new_value=1, old_value=0)\nTrue\n&gt;&gt;&gt; record.is_better(new_value=0, old_value=1)\nFalse\n</code></pre>"},{"location":"refs/comparable/#minrecord.comparable.MaxScalarRecord","title":"minrecord.comparable.MaxScalarRecord","text":"<p>               Bases: <code>ComparableRecord[Number]</code></p> <p>A specific implementation to track the max value of a scalar record.</p> <p>This record uses the <code>MaxScalarComparator</code> to find the best value of the record.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"value\")\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/comparable/#minrecord.comparable.MaxScalarRecord.from_elements","title":"minrecord.comparable.MaxScalarRecord.from_elements  <code>classmethod</code>","text":"<pre><code>from_elements(\n    name: str, elements: Iterable[tuple[float | None, T]]\n) -&gt; Self\n</code></pre> <p>Instantiate a <code>MaxScalarRecord</code> object from the elements.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord.from_elements(\"value\", ((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/comparable/#minrecord.comparable.MinScalarRecord","title":"minrecord.comparable.MinScalarRecord","text":"<p>               Bases: <code>ComparableRecord[Number]</code></p> <p>A specific implementation to track the min value of a scalar record.</p> <p>This record uses the <code>MinScalarComparator</code> to find the best value of the record.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best  value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"value\")\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n42.0\n</code></pre>"},{"location":"refs/comparable/#minrecord.comparable.MinScalarRecord.from_elements","title":"minrecord.comparable.MinScalarRecord.from_elements  <code>classmethod</code>","text":"<pre><code>from_elements(\n    name: str, elements: Iterable[tuple[float | None, T]]\n) -&gt; Self\n</code></pre> <p>Instantiate a <code>MaxScalarRecord</code> object from the elements.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord.from_elements(\"value\", ((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n42.0\n</code></pre>"},{"location":"refs/comparator/","title":"minrecord.comparator","text":""},{"location":"refs/comparator/#minrecord.comparator","title":"minrecord.comparator","text":"<p>Contain the comparator base class and some implementations.</p>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator","title":"minrecord.comparator.BaseComparator","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base comparator class to implement a comparator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator.equal","title":"minrecord.comparator.BaseComparator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two comparators are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the comparators are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator, MaxScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.equal(MinScalarComparator())\nTrue\n&gt;&gt;&gt; comparator.equal(MaxScalarComparator())\nFalse\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator.get_initial_best_value","title":"minrecord.comparator.BaseComparator.get_initial_best_value  <code>abstractmethod</code>","text":"<pre><code>get_initial_best_value() -&gt; T\n</code></pre> <p>Get the initial best value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The initial best value.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator.is_better","title":"minrecord.comparator.BaseComparator.is_better  <code>abstractmethod</code>","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.ComparatorEqualityComparator","title":"minrecord.comparator.ComparatorEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[BaseComparator]</code></p> <p>Implement an equality comparator for <code>BaseBatch</code> objects.</p>"},{"location":"refs/comparator/#minrecord.comparator.MaxScalarComparator","title":"minrecord.comparator.MaxScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implement a max comparator for scalar value.</p> <p>This comparator can be used to find the maximum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarComparator\n&gt;&gt;&gt; comparator = MaxScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nTrue\n&gt;&gt;&gt; comparator.get_initial_best_value()\n-inf\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.MinScalarComparator","title":"minrecord.comparator.MinScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implementation of a min comparator for scalar value.</p> <p>This comparator can be used to find the minimum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/functional/","title":"minrecord.functional","text":""},{"location":"refs/functional/#minrecord.functional","title":"minrecord.functional","text":"<p>Contain functions to manipulate records.</p>"},{"location":"refs/functional/#minrecord.functional.get_best_values","title":"minrecord.functional.get_best_values","text":"<pre><code>get_best_values(\n    records: Mapping[str, BaseRecord[Any]],\n    prefix: str = \"\",\n    suffix: str = \"\",\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the best value of each record.</p> <p>This function ignores the empty and non-comparable records.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Mapping[str, BaseRecord[Any]]</code> <p>The records and their associated keys.</p> required <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import (\n...     MinScalarRecord,\n...     MaxScalarRecord,\n...     get_best_values,\n... )\n&gt;&gt;&gt; record1 = MinScalarRecord.from_elements(\"loss\", elements=[(None, 1.9), (None, 1.2)])\n&gt;&gt;&gt; record2 = MaxScalarRecord.from_elements(\"accuracy\", elements=[(None, 42), (None, 35)])\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2})\n{'loss': 1.2, 'accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, prefix=\"best/\")\n{'best/loss': 1.2, 'best/accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, suffix=\"/best\")\n{'loss/best': 1.2, 'accuracy/best': 42}\n</code></pre>"},{"location":"refs/functional/#minrecord.functional.get_last_values","title":"minrecord.functional.get_last_values","text":"<pre><code>get_last_values(\n    records: Mapping[str, BaseRecord[Any]],\n    prefix: str = \"\",\n    suffix: str = \"\",\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the last value of each record.</p> <p>This function ignores the empty records.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Mapping[str, BaseRecord[Any]]</code> <p>The records and their associated keys.</p> required <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import (\n...     MinScalarRecord,\n...     MaxScalarRecord,\n...     get_last_values,\n... )\n&gt;&gt;&gt; record1 = MinScalarRecord.from_elements(\"loss\", elements=[(None, 1.9), (None, 1.2)])\n&gt;&gt;&gt; record2 = MaxScalarRecord.from_elements(\"accuracy\", elements=[(None, 42), (None, 35)])\n&gt;&gt;&gt; get_last_values({\"loss\": record1, \"accuracy\": record2})\n{'loss': 1.2, 'accuracy': 35}\n&gt;&gt;&gt; get_last_values({\"loss\": record1, \"accuracy\": record2}, prefix=\"last/\")\n{'last/loss': 1.2, 'last/accuracy': 35}\n&gt;&gt;&gt; get_last_values({\"loss\": record1, \"accuracy\": record2}, suffix=\"/last\")\n{'loss/last': 1.2, 'accuracy/last': 35}\n</code></pre>"},{"location":"refs/generic/","title":"minrecord.generic","text":""},{"location":"refs/generic/#minrecord.generic","title":"minrecord.generic","text":"<p>Contain the generic record implementation.</p>"},{"location":"refs/generic/#minrecord.generic.Record","title":"minrecord.generic.Record","text":"<p>               Bases: <code>BaseRecord[T]</code></p> <p>Implement a generic record to store the recent values.</p> <p>Internally, this class uses a <code>deque</code> to keep the most recent values added in the record. Note that this class does not allow to get the best value because it is not possible to define a generic rule to know the best object. Please see <code>ScalarRecord</code> that can compute the best value for scalars.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements in the record. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum size of the record.</p> <code>get_max_size()</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(name=\"value\", elements=((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record\nRecord(name=value, max_size=10, size=2)\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n</code></pre>"},{"location":"refs/generic/#minrecord.generic.Record.max_size","title":"minrecord.generic.Record.max_size  <code>property</code>","text":"<pre><code>max_size: int\n</code></pre> <p>The maximum size of the record.</p>"},{"location":"refs/manager/","title":"minrecord.manager","text":""},{"location":"refs/manager/#minrecord.manager","title":"minrecord.manager","text":"<p>Contain a record manager implementation.</p>"},{"location":"refs/manager/#minrecord.manager.RecordManager","title":"minrecord.manager.RecordManager","text":"<p>Implement a simple record manager.</p> <p>This class proposes an approach to manage a group of records, but it is possible to use other approaches. If this class does not fit your needs, feel free to use another approach.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>dict[str, BaseRecord[Any]] | None</code> <p>The initial records to add to the manager.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.get_record(\"loss\")\nMinScalarRecord(name=loss, max_size=10, size=0)\n&gt;&gt;&gt; manager.get_record(\"new_record\")\nRecord(name=new_record, max_size=10, size=0)\n</code></pre>"},{"location":"refs/manager/#minrecord.manager.RecordManager.add_record","title":"minrecord.manager.RecordManager.add_record","text":"<pre><code>add_record(\n    record: BaseRecord[Any],\n    key: str | None = None,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a record to the manager.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>BaseRecord[Any]</code> <p>The record to add to the manager.</p> required <code>key</code> <code>str | None</code> <p>The key to store the record. If <code>None</code>, the name of the record is used.</p> <code>None</code> <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the key already exists. This parameter should be set to <code>True</code> to overwrite the record for this key.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a record is already registered for the key and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager\nRecordManager(\n  (loss): MinScalarRecord(name=loss, max_size=10, size=0)\n)\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"), \"my key\")\n&gt;&gt;&gt; manager\nRecordManager(\n  (loss): MinScalarRecord(name=loss, max_size=10, size=0)\n  (my key): MinScalarRecord(name=loss, max_size=10, size=0)\n)\n</code></pre>"},{"location":"refs/manager/#minrecord.manager.RecordManager.get_best_values","title":"minrecord.manager.RecordManager.get_best_values","text":"<pre><code>get_best_values(\n    prefix: str = \"\", suffix: str = \"\"\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the best value of each metric.</p> <p>This method ignores the metrics with empty record and the non-comparable record.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the metric name to avoid confusion. By default, the returned dict uses the same name as the metric.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the metric name to avoid confusion. By default, the returned dict uses the same name as the metric.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each metric.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MaxScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MaxScalarRecord(\"accuracy\"))\n&gt;&gt;&gt; manager.get_record(\"accuracy\").add_value(42.0)\n&gt;&gt;&gt; manager.get_best_values()\n{'accuracy': 42.0}\n&gt;&gt;&gt; manager.get_best_values(prefix=\"best/\")\n{'best/accuracy': 42.0}\n&gt;&gt;&gt; manager.get_best_values(suffix=\"/best\")\n{'accuracy/best': 42.0}\n</code></pre>"},{"location":"refs/manager/#minrecord.manager.RecordManager.get_record","title":"minrecord.manager.RecordManager.get_record","text":"<pre><code>get_record(key: str) -&gt; BaseRecord[Any]\n</code></pre> <p>Get the record associated to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the record to retrieve.</p> required <p>Returns:</p> Type Description <code>BaseRecord[Any]</code> <p>The record if it exists, otherwise it returns an empty record. The created empty record is a <code>Record</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.get_record(\"loss\")\nMinScalarRecord(name=loss, max_size=10, size=0)\n&gt;&gt;&gt; manager.get_record(\"new_record\")\nRecord(name=new_record, max_size=10, size=0)\n</code></pre>"},{"location":"refs/manager/#minrecord.manager.RecordManager.get_records","title":"minrecord.manager.RecordManager.get_records","text":"<pre><code>get_records() -&gt; dict[str, BaseRecord[Any]]\n</code></pre> <p>Get all the records.</p> <p>Returns:</p> Type Description <code>dict[str, BaseRecord[Any]]</code> <p>The records with their associated keys.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.get_records()\n{'loss': MinScalarRecord(name=loss, max_size=10, size=0)}\n</code></pre>"},{"location":"refs/manager/#minrecord.manager.RecordManager.has_record","title":"minrecord.manager.RecordManager.has_record","text":"<pre><code>has_record(key: str) -&gt; bool\n</code></pre> <p>Indicate if the engine has a record for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the record to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the record exists, <code>False</code> otherwise</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.has_record(\"loss\")\nTrue\n&gt;&gt;&gt; manager.has_record(\"missing\")\nFalse\n</code></pre>"},{"location":"refs/manager/#minrecord.manager.RecordManager.load_state_dict","title":"minrecord.manager.RecordManager.load_state_dict","text":"<pre><code>load_state_dict(state_dict: dict[str, Any]) -&gt; None\n</code></pre> <p>Load the state values from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict[str, Any]</code> <p>A dict with the new state values.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, Record\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(Record(\"value\"))\n&gt;&gt;&gt; manager.load_state_dict({\"value\": {\"state\": {\"record\": ((0, 1), (1, 0.5), (2, 0.25))}}})\n&gt;&gt;&gt; manager.get_record(\"value\").get_last_value()\n0.25\n</code></pre>"},{"location":"refs/manager/#minrecord.manager.RecordManager.state_dict","title":"minrecord.manager.RecordManager.state_dict","text":"<pre><code>state_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return a dictionary containing state values of all the records.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dictionary containing state values of all the records.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.state_dict()\n{}\n</code></pre>"},{"location":"refs/root/","title":"minrecord","text":""},{"location":"refs/root/#minrecord","title":"minrecord","text":"<p>Root package.</p>"},{"location":"refs/root/#minrecord.BaseComparator","title":"minrecord.BaseComparator","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base comparator class to implement a comparator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/#minrecord.BaseComparator.equal","title":"minrecord.BaseComparator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two comparators are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the comparators are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator, MaxScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.equal(MinScalarComparator())\nTrue\n&gt;&gt;&gt; comparator.equal(MaxScalarComparator())\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.BaseComparator.get_initial_best_value","title":"minrecord.BaseComparator.get_initial_best_value  <code>abstractmethod</code>","text":"<pre><code>get_initial_best_value() -&gt; T\n</code></pre> <p>Get the initial best value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The initial best value.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/#minrecord.BaseComparator.is_better","title":"minrecord.BaseComparator.is_better  <code>abstractmethod</code>","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord","title":"minrecord.BaseRecord","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Define the base class to implement a record.</p> <p>The record tracks the value added as well as the step when the value is added. The goal of this class is to track the recent record because the loggers (e.g. MLFlow or Tensorboard) do not allow to get the last value or the best value. The record keeps in memory a recent record of pairs (step, value) where step is the index of the step when the value was added. The length of the recent record depends on the concrete implementation.</p> <p>To implement your own record, you will need to define the following methods:</p> <pre><code>- ``add_value``\n- ``get_last_value``\n- ``get_most_recent``\n- ``is_comparable``\n- ``is_empty``\n- ``update``\n- ``load_state_dict``\n- ``state_dict``\n</code></pre> <p>If it is a comparable record, you will need to implement the following methods too:</p> <pre><code>- ``_get_best_value``\n- ``_has_improved``\n</code></pre> <p>You may also need to extend the <code>config_dict</code> method.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.get_last_value()\n1.2\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.name","title":"minrecord.BaseRecord.name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the record.</p>"},{"location":"refs/root/#minrecord.BaseRecord.add_value","title":"minrecord.BaseRecord.add_value  <code>abstractmethod</code>","text":"<pre><code>add_value(value: T, step: float | None = None) -&gt; None\n</code></pre> <p>Add a new value to the record.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to add to the record.</p> required <code>step</code> <code>float | None</code> <p>The step value to record. <code>None</code> means there is no step to track.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2)\n&gt;&gt;&gt; record.add_value(value=42, step=1)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=2)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.clone","title":"minrecord.BaseRecord.clone  <code>abstractmethod</code>","text":"<pre><code>clone() -&gt; BaseRecord[T]\n</code></pre> <p>Clone the current record.</p> <p>Returns:</p> Type Description <code>BaseRecord[T]</code> <p>A copy of the current record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record_cloned = record.clone()\n&gt;&gt;&gt; record_cloned\nRecord(name=loss, max_size=10, size=0)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.config_dict","title":"minrecord.BaseRecord.config_dict","text":"<pre><code>config_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get the config of the record.</p> <p>The config dictionary should contain all the values necessary to instantiate a record with the same parameters with the  <code>factory</code> method. It is expected to contain values like the full name of the class and the arguments of the constructor. This dictionary should not contain the state values. It is possible to get the state values with the <code>state_dict</code> method.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The config of the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord, Record\n&gt;&gt;&gt; config = Record(\"loss\").config_dict()\n&gt;&gt;&gt; record = BaseRecord.factory(**config)  # Note that the state is not copied.\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=0)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.equal","title":"minrecord.BaseRecord.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two records are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the records are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record1 = Record(\"loss\")\n&gt;&gt;&gt; record2 = Record(\"accuracy\")\n&gt;&gt;&gt; record3 = Record(\"loss\")\n&gt;&gt;&gt; record1.equal(record2)\nFalse\n&gt;&gt;&gt; record1.equal(record1)\nTrue\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.from_dict","title":"minrecord.BaseRecord.from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; BaseRecord[T]\n</code></pre> <p>Instantiate a record from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The dictionary that is used to instantiate the record. The dictionary is expected to contain the parameters to create instantiate the record and the state of the record.</p> required <p>Returns:</p> Type Description <code>BaseRecord[T]</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord\n&gt;&gt;&gt; from objectory import OBJECT_TARGET\n&gt;&gt;&gt; record = BaseRecord.from_dict(\n...     {\n...         \"config\": {\n...             OBJECT_TARGET: \"minrecord.Record\",\n...             \"name\": \"loss\",\n...             \"max_size\": 7,\n...         },\n...         \"state\": {\"record\": ((0, 1), (1, 5))},\n...     }\n... )\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=7, size=2)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.get_best_value","title":"minrecord.BaseRecord.get_best_value","text":"<pre><code>get_best_value() -&gt; T\n</code></pre> <p>Get the best value of this record.</p> <p>It is possible to get the best value only if it is a comparable record i.e. it is possible to compare the values in the record.</p> <p>Returns:</p> Type Description <code>T</code> <p>The best value of this record.</p> <p>Raises:</p> Type Description <code>NotAComparableRecord</code> <p>if it is not a comparable record.</p> <code>EmptyRecordError</code> <p>if the record is empty</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=4, step=1)\n&gt;&gt;&gt; record.get_best_value()\n4\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.get_last_value","title":"minrecord.BaseRecord.get_last_value  <code>abstractmethod</code>","text":"<pre><code>get_last_value() -&gt; T\n</code></pre> <p>Get the last value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The last value added in the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.get_last_value()\n1.2\n&gt;&gt;&gt; record.add_value(value=0.8, step=1)\n&gt;&gt;&gt; record.get_last_value()\n0.8\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.get_most_recent","title":"minrecord.BaseRecord.get_most_recent  <code>abstractmethod</code>","text":"<pre><code>get_most_recent() -&gt; tuple[tuple[float | None, T], ...]\n</code></pre> <p>Get the tuple of recent values and their associated steps.</p> <p>The last value in the tuple is the last value added to the record. The length of the recent record depends on the concrete implementation.</p> <p>Returns:</p> Type Description <code>tuple[tuple[float | None, T], ...]</code> <p>A tuple of the recent values in the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.add_value(value=0.8, step=2)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 2), (1, 1.2), (2, 0.8))\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.has_improved","title":"minrecord.BaseRecord.has_improved","text":"<pre><code>has_improved() -&gt; bool\n</code></pre> <p>Indicate if the last value is the best value.</p> <p>It is possible to use this method only if it is a comparable record i.e. it is possible to compare the values in the record.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the last value is the best value, otherwise <code>False</code>.</p> <p>Raises:</p> Type Description <code>NotAComparableRecord</code> <p>if it is not a comparable record.</p> <code>EmptyRecordError</code> <p>if the record is empty</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=4, step=1)\n&gt;&gt;&gt; record.has_improved()\nTrue\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.is_comparable","title":"minrecord.BaseRecord.is_comparable  <code>abstractmethod</code>","text":"<pre><code>is_comparable() -&gt; bool\n</code></pre> <p>Indicate if it is possible to compare the values in the record.</p> <p>Note that it is possible to compute the best value only for records that are comparable.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if it is possible to compare the values in the record, otherwise <code>False</code>.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_comparable()\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.is_empty","title":"minrecord.BaseRecord.is_empty  <code>abstractmethod</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Indicate if the record is empty or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the record is empty, otherwise <code>False</code>.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_empty()\nTrue\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.load_state_dict","title":"minrecord.BaseRecord.load_state_dict  <code>abstractmethod</code>","text":"<pre><code>load_state_dict(state_dict: dict[str, Any]) -&gt; None\n</code></pre> <p>Set up the record from a dictionary containing the state values.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict[str, Any]</code> <p>A dictionary containing state keys with values.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.load_state_dict({\"record\": ((0, 42.0),)})\n&gt;&gt;&gt; record.get_last_value()\n42.0\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.state_dict","title":"minrecord.BaseRecord.state_dict  <code>abstractmethod</code>","text":"<pre><code>state_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get a dictionary containing the state values of the record.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The state values in a dict.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(42.0, step=0)\n&gt;&gt;&gt; state = record.state_dict()\n&gt;&gt;&gt; state\n{'record': ((0, 42.0),)}\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.to_dict","title":"minrecord.BaseRecord.to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Export the current record to a dictionary.</p> <p>This method exports all the information to re-create the record with the same state. The returned dictionary can be used as input of the <code>from_dict</code> method to resume the record.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with the config and the state of the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord, Record\n&gt;&gt;&gt; record_dict = Record(\"loss\").to_dict()\n&gt;&gt;&gt; record = BaseRecord.from_dict(record_dict)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=0)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.update","title":"minrecord.BaseRecord.update  <code>abstractmethod</code>","text":"<pre><code>update(elements: Iterable[tuple[float | None, T]]) -&gt; None\n</code></pre> <p>Update the record by adding the elements.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The elements to add to the record.  Each tuple has the following structure <code>(step, value)</code>. The step can be <code>None</code> if there is no step.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.update([(0, 42), (1, 45)])\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=2)\n</code></pre>"},{"location":"refs/root/#minrecord.ComparableRecord","title":"minrecord.ComparableRecord","text":"<p>               Bases: <code>Record[T]</code></p> <p>Implement a record of comparable values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>comparator</code> <code>BaseComparator[T]</code> <p>The comparator to use to find the best value.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store in the record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import ComparableRecord\n&gt;&gt;&gt; from minrecord.comparator import MaxScalarComparator\n&gt;&gt;&gt; record = ComparableRecord(\"value\", MaxScalarComparator())\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.ComparableRecord.is_better","title":"minrecord.ComparableRecord.is_better","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import ComparableRecord\n&gt;&gt;&gt; from minrecord.comparator import MaxScalarComparator\n&gt;&gt;&gt; record = ComparableRecord(\"accuracy\", MaxScalarComparator())\n&gt;&gt;&gt; record.is_better(new_value=1, old_value=0)\nTrue\n&gt;&gt;&gt; record.is_better(new_value=0, old_value=1)\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.EmptyRecordError","title":"minrecord.EmptyRecordError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise an error if the record is empty.</p>"},{"location":"refs/root/#minrecord.MaxScalarComparator","title":"minrecord.MaxScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implement a max comparator for scalar value.</p> <p>This comparator can be used to find the maximum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarComparator\n&gt;&gt;&gt; comparator = MaxScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nTrue\n&gt;&gt;&gt; comparator.get_initial_best_value()\n-inf\n</code></pre>"},{"location":"refs/root/#minrecord.MaxScalarRecord","title":"minrecord.MaxScalarRecord","text":"<p>               Bases: <code>ComparableRecord[Number]</code></p> <p>A specific implementation to track the max value of a scalar record.</p> <p>This record uses the <code>MaxScalarComparator</code> to find the best value of the record.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"value\")\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.MaxScalarRecord.from_elements","title":"minrecord.MaxScalarRecord.from_elements  <code>classmethod</code>","text":"<pre><code>from_elements(\n    name: str, elements: Iterable[tuple[float | None, T]]\n) -&gt; Self\n</code></pre> <p>Instantiate a <code>MaxScalarRecord</code> object from the elements.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord.from_elements(\"value\", ((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.MinScalarComparator","title":"minrecord.MinScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implementation of a min comparator for scalar value.</p> <p>This comparator can be used to find the minimum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/#minrecord.MinScalarRecord","title":"minrecord.MinScalarRecord","text":"<p>               Bases: <code>ComparableRecord[Number]</code></p> <p>A specific implementation to track the min value of a scalar record.</p> <p>This record uses the <code>MinScalarComparator</code> to find the best value of the record.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best  value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"value\")\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n42.0\n</code></pre>"},{"location":"refs/root/#minrecord.MinScalarRecord.from_elements","title":"minrecord.MinScalarRecord.from_elements  <code>classmethod</code>","text":"<pre><code>from_elements(\n    name: str, elements: Iterable[tuple[float | None, T]]\n) -&gt; Self\n</code></pre> <p>Instantiate a <code>MaxScalarRecord</code> object from the elements.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord.from_elements(\"value\", ((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n42.0\n</code></pre>"},{"location":"refs/root/#minrecord.NotAComparableRecordError","title":"minrecord.NotAComparableRecordError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise an error if it is not possible to compare the values in the record.</p>"},{"location":"refs/root/#minrecord.Record","title":"minrecord.Record","text":"<p>               Bases: <code>BaseRecord[T]</code></p> <p>Implement a generic record to store the recent values.</p> <p>Internally, this class uses a <code>deque</code> to keep the most recent values added in the record. Note that this class does not allow to get the best value because it is not possible to define a generic rule to know the best object. Please see <code>ScalarRecord</code> that can compute the best value for scalars.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements in the record. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum size of the record.</p> <code>get_max_size()</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(name=\"value\", elements=((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record\nRecord(name=value, max_size=10, size=2)\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n</code></pre>"},{"location":"refs/root/#minrecord.Record.max_size","title":"minrecord.Record.max_size  <code>property</code>","text":"<pre><code>max_size: int\n</code></pre> <p>The maximum size of the record.</p>"},{"location":"refs/root/#minrecord.RecordManager","title":"minrecord.RecordManager","text":"<p>Implement a simple record manager.</p> <p>This class proposes an approach to manage a group of records, but it is possible to use other approaches. If this class does not fit your needs, feel free to use another approach.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>dict[str, BaseRecord[Any]] | None</code> <p>The initial records to add to the manager.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.get_record(\"loss\")\nMinScalarRecord(name=loss, max_size=10, size=0)\n&gt;&gt;&gt; manager.get_record(\"new_record\")\nRecord(name=new_record, max_size=10, size=0)\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.add_record","title":"minrecord.RecordManager.add_record","text":"<pre><code>add_record(\n    record: BaseRecord[Any],\n    key: str | None = None,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a record to the manager.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>BaseRecord[Any]</code> <p>The record to add to the manager.</p> required <code>key</code> <code>str | None</code> <p>The key to store the record. If <code>None</code>, the name of the record is used.</p> <code>None</code> <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the key already exists. This parameter should be set to <code>True</code> to overwrite the record for this key.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a record is already registered for the key and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager\nRecordManager(\n  (loss): MinScalarRecord(name=loss, max_size=10, size=0)\n)\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"), \"my key\")\n&gt;&gt;&gt; manager\nRecordManager(\n  (loss): MinScalarRecord(name=loss, max_size=10, size=0)\n  (my key): MinScalarRecord(name=loss, max_size=10, size=0)\n)\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.get_best_values","title":"minrecord.RecordManager.get_best_values","text":"<pre><code>get_best_values(\n    prefix: str = \"\", suffix: str = \"\"\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the best value of each metric.</p> <p>This method ignores the metrics with empty record and the non-comparable record.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the metric name to avoid confusion. By default, the returned dict uses the same name as the metric.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the metric name to avoid confusion. By default, the returned dict uses the same name as the metric.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each metric.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MaxScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MaxScalarRecord(\"accuracy\"))\n&gt;&gt;&gt; manager.get_record(\"accuracy\").add_value(42.0)\n&gt;&gt;&gt; manager.get_best_values()\n{'accuracy': 42.0}\n&gt;&gt;&gt; manager.get_best_values(prefix=\"best/\")\n{'best/accuracy': 42.0}\n&gt;&gt;&gt; manager.get_best_values(suffix=\"/best\")\n{'accuracy/best': 42.0}\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.get_record","title":"minrecord.RecordManager.get_record","text":"<pre><code>get_record(key: str) -&gt; BaseRecord[Any]\n</code></pre> <p>Get the record associated to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the record to retrieve.</p> required <p>Returns:</p> Type Description <code>BaseRecord[Any]</code> <p>The record if it exists, otherwise it returns an empty record. The created empty record is a <code>Record</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.get_record(\"loss\")\nMinScalarRecord(name=loss, max_size=10, size=0)\n&gt;&gt;&gt; manager.get_record(\"new_record\")\nRecord(name=new_record, max_size=10, size=0)\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.get_records","title":"minrecord.RecordManager.get_records","text":"<pre><code>get_records() -&gt; dict[str, BaseRecord[Any]]\n</code></pre> <p>Get all the records.</p> <p>Returns:</p> Type Description <code>dict[str, BaseRecord[Any]]</code> <p>The records with their associated keys.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.get_records()\n{'loss': MinScalarRecord(name=loss, max_size=10, size=0)}\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.has_record","title":"minrecord.RecordManager.has_record","text":"<pre><code>has_record(key: str) -&gt; bool\n</code></pre> <p>Indicate if the engine has a record for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the record to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the record exists, <code>False</code> otherwise</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.has_record(\"loss\")\nTrue\n&gt;&gt;&gt; manager.has_record(\"missing\")\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.load_state_dict","title":"minrecord.RecordManager.load_state_dict","text":"<pre><code>load_state_dict(state_dict: dict[str, Any]) -&gt; None\n</code></pre> <p>Load the state values from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict[str, Any]</code> <p>A dict with the new state values.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, Record\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(Record(\"value\"))\n&gt;&gt;&gt; manager.load_state_dict({\"value\": {\"state\": {\"record\": ((0, 1), (1, 0.5), (2, 0.25))}}})\n&gt;&gt;&gt; manager.get_record(\"value\").get_last_value()\n0.25\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.state_dict","title":"minrecord.RecordManager.state_dict","text":"<pre><code>state_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return a dictionary containing state values of all the records.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dictionary containing state values of all the records.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.state_dict()\n{}\n</code></pre>"},{"location":"refs/root/#minrecord.get_best_values","title":"minrecord.get_best_values","text":"<pre><code>get_best_values(\n    records: Mapping[str, BaseRecord[Any]],\n    prefix: str = \"\",\n    suffix: str = \"\",\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the best value of each record.</p> <p>This function ignores the empty and non-comparable records.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Mapping[str, BaseRecord[Any]]</code> <p>The records and their associated keys.</p> required <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import (\n...     MinScalarRecord,\n...     MaxScalarRecord,\n...     get_best_values,\n... )\n&gt;&gt;&gt; record1 = MinScalarRecord.from_elements(\"loss\", elements=[(None, 1.9), (None, 1.2)])\n&gt;&gt;&gt; record2 = MaxScalarRecord.from_elements(\"accuracy\", elements=[(None, 42), (None, 35)])\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2})\n{'loss': 1.2, 'accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, prefix=\"best/\")\n{'best/loss': 1.2, 'best/accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, suffix=\"/best\")\n{'loss/best': 1.2, 'accuracy/best': 42}\n</code></pre>"},{"location":"refs/root/#minrecord.get_last_values","title":"minrecord.get_last_values","text":"<pre><code>get_last_values(\n    records: Mapping[str, BaseRecord[Any]],\n    prefix: str = \"\",\n    suffix: str = \"\",\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the last value of each record.</p> <p>This function ignores the empty records.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Mapping[str, BaseRecord[Any]]</code> <p>The records and their associated keys.</p> required <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import (\n...     MinScalarRecord,\n...     MaxScalarRecord,\n...     get_last_values,\n... )\n&gt;&gt;&gt; record1 = MinScalarRecord.from_elements(\"loss\", elements=[(None, 1.9), (None, 1.2)])\n&gt;&gt;&gt; record2 = MaxScalarRecord.from_elements(\"accuracy\", elements=[(None, 42), (None, 35)])\n&gt;&gt;&gt; get_last_values({\"loss\": record1, \"accuracy\": record2})\n{'loss': 1.2, 'accuracy': 35}\n&gt;&gt;&gt; get_last_values({\"loss\": record1, \"accuracy\": record2}, prefix=\"last/\")\n{'last/loss': 1.2, 'last/accuracy': 35}\n&gt;&gt;&gt; get_last_values({\"loss\": record1, \"accuracy\": record2}, suffix=\"/last\")\n{'loss/last': 1.2, 'accuracy/last': 35}\n</code></pre>"},{"location":"refs/root/#minrecord.get_max_size","title":"minrecord.get_max_size","text":"<pre><code>get_max_size() -&gt; int\n</code></pre> <p>Get the current default maximum size of values to track in each record.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current default maximum size of values to track in each record.</p> <p>This value can be changed by using <code>set_max_size</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import get_max_size\n&gt;&gt;&gt; get_max_size()\n10\n</code></pre>"},{"location":"refs/root/#minrecord.set_max_size","title":"minrecord.set_max_size","text":"<pre><code>set_max_size(max_size: int) -&gt; None\n</code></pre> <p>Set the default maximum size of values to track in each record.</p> <p>This function does not change the maximum size of records that are already created. It only changes the maximum size of records that will be created after the call of this function.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>The new default maximum size of values to track in each record.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import get_max_size, set_max_size\n&gt;&gt;&gt; get_max_size()\n10\n&gt;&gt;&gt; set_max_size(5)\n&gt;&gt;&gt; get_max_size()\n5\n</code></pre>"},{"location":"refs/utils/","title":"minrecord.utils","text":""},{"location":"refs/utils/#minrecord.utils","title":"minrecord.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#minrecord.utils.value","title":"minrecord.utils.value","text":"<p>Contain utility functions to manage objects.</p>"},{"location":"refs/utils/#minrecord.utils.value.MutableValue","title":"minrecord.utils.value.MutableValue","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Implement a simple class to build a mutable object.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The initial value.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord.utils.value import MutableValue\n&gt;&gt;&gt; value = MutableValue(10)\n&gt;&gt;&gt; value.get_value()\n10\n&gt;&gt;&gt; value.set_value(42)\n&gt;&gt;&gt; value.get_value()\n42\n</code></pre>"},{"location":"refs/utils/#minrecord.utils.value.MutableValue.get_value","title":"minrecord.utils.value.MutableValue.get_value","text":"<pre><code>get_value() -&gt; T\n</code></pre> <p>Get the current value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value.</p>"},{"location":"refs/utils/#minrecord.utils.value.MutableValue.set_value","title":"minrecord.utils.value.MutableValue.set_value","text":"<pre><code>set_value(value: T) -&gt; None\n</code></pre> <p>Set a new value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The new value.</p> required"}]}