{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>minrecord</code> is a minimalist Python library to record values in a ML workflow. In particular, it provides functionalities to track the best value, or the most recent values by storing a limiting number of values. It is possible to customize the library e.g. it is possible to define a new logic to track the best value. Below is an example to show how to track the best scalar value when the best value is the maximum value and when the best value is the minimum value.</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord, MinScalarRecord\n&gt;&gt;&gt; record_max = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record_max.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record_max.add_value(40)\n&gt;&gt;&gt; record_max.get_best_value()\n46\n&gt;&gt;&gt; record_min = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record_min.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record_min.add_value(50)\n&gt;&gt;&gt; record_min.get_best_value()\n42\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>minrecord</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>minrecord</code> to a new version will possibly break any code that was using the old version of <code>minrecord</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>minrecord</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install minrecord\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>minrecord</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'minrecord[all]'\n</code></pre> <p>This command also installed NumPy and PyTorch. It is also possible to install the optional packages manually or to select the packages to install. In the following example, only NumPy is installed:</p> <pre><code>pip install minrecord numpy\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>minrecord</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/minrecord.git\n</code></pre> <p>It is recommended to create a Python 3.9+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate minrecord\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>minrecord</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p> This page gives a quick overview on how to use the <code>minrecord</code>. You should read this page if you want to learn how to use the records. This page does not explain the internal behavior of the records. While <code>minrecord</code> was designed to work in a ML workflow, you can use it in other contexts if it fits your need.</p> <p>Prerequisites: You\u2019ll need to know a bit of Python. For a refresher, see the Python tutorial.</p>"},{"location":"quickstart/#record","title":"Record","text":"<p><code>minrecord</code> is organized around the <code>BaseRecord</code> class. It defines the interface to implement a record object. <code>minrecord</code> provides the <code>Record</code> class, which is a generic implementation of a record. Each <code>Record</code> object has a name and tracks the last values.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=0)\n&gt;&gt;&gt; record.name\n'loss'\n</code></pre> <p>Usually, it is useful to keep only the last values, but it also possible to track a large number of values, but it can consume a lot of memory of the values to track take significant amount of memory. By default, the <code>Record</code> objects only track the last 10 values, but it is possible to control the memory consumption by setting carefully the <code>max_size</code> argument.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"my_record\", max_size=5)\n&gt;&gt;&gt; record\nRecord(name=my_record, max_size=5, size=0)\n</code></pre> <p>After creating a record, the <code>add_record</code> method can be used to add a value to the record. The following example shows how to add the value <code>4.2</code> to the record.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(4.2)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=1)\n</code></pre> <p>When adding a value, it is possible to specify a step to track when the value was added.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(4.2, step=2)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=1)\n</code></pre> <p>The step can be a number or <code>None</code>. <code>None</code> means no valid step to track. It is possible to get the last value added by using the <code>get_best_value</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(4.2, step=1)\n&gt;&gt;&gt; record.add_value(2.4, step=2)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=2)\n&gt;&gt;&gt; record.get_last_value()\n2.4\n</code></pre> <p>Calling <code>get_best_value</code> on an empty record raises a <code>EmptyRecordError</code> exception. It is possible to check if a record is empty or not by using the <code>is_empty</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_empty()\nTrue\n&gt;&gt;&gt; record.add_value(4.2, step=1)\n&gt;&gt;&gt; record.is_empty()\nFalse\n</code></pre> <p>If there are multiple values to add, it is possible to use the <code>update</code> method. The input is a sequence of 2-tuples where the first item is the step and the second item is the value.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=3)\n&gt;&gt;&gt; record.get_last_value()\n46\n</code></pre> <p>In the example above, the second element does not have a valid step so the value is set to <code>None</code>. It is possible to add elements when creating the record.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=3)\n&gt;&gt;&gt; record.get_last_value()\n46\n</code></pre> <p>It is possible to access the most recent values added to the record by using the <code>get_most_recent</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(40)\n&gt;&gt;&gt; record.get_most_recent()\n((0, 42), (None, 45), (2, 46), (None, 40))\n</code></pre> <p>It is possible to check if two <code>Record</code> objects are equal by calling the <code>equal</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record1 = Record(\"loss\")\n&gt;&gt;&gt; record2 = Record(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record3 = Record(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record1.equal(record2)\nFalse\n&gt;&gt;&gt; record3.equal(record2)\nTrue\n</code></pre>"},{"location":"quickstart/#comparable-record","title":"Comparable Record","text":"<p><code>minrecord</code> also provides some comparable records i.e. records that track the best value. There is a generic <code>ComparableRecord</code> class where the user just needs to implement the comparator object that is used to find the nest value. There are <code>MaxScalarRecord</code> and <code>MinScalarRecord</code> that are specialized implementations of <code>ComparableRecord</code> for scalars (e.g. <code>float</code> or <code>int</code>). It is possible to know if a record is comparable by calling the <code>is_comparable</code> methods.</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord, MinScalarRecord, Record\n&gt;&gt;&gt; record = Record(\"my_value\")\n&gt;&gt;&gt; record.is_comparable()\nFalse\n&gt;&gt;&gt; record_max = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record_max.is_comparable()\nTrue\n&gt;&gt;&gt; record_min = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record_min.is_comparable()\nTrue\n</code></pre> <p>These records support the <code>Record</code> functionalities, and additional functionalities. It is possible to use the <code>get_best_value</code> method to get the best value.</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord, MinScalarRecord\n&gt;&gt;&gt; record_max = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record_max.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record_max.add_value(40)\n&gt;&gt;&gt; record_max.get_best_value()\n46\n&gt;&gt;&gt; record_min = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record_min.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record_min.add_value(50)\n&gt;&gt;&gt; record_min.get_best_value()\n42\n</code></pre> <p>The record tracks the best value even if the best value is not store in the record. Below is an example where the record's maximum size is set to 3.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\", max_size=3)\n&gt;&gt;&gt; record.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.add_value(60)\n&gt;&gt;&gt; record.get_most_recent()\n((2, 46), (None, 50), (None, 60))\n&gt;&gt;&gt; record.get_best_value()\n42\n</code></pre> <p>Calling <code>get_best_value</code> on an empty record raises an <code>EmptyRecordError</code> exception. It is possible to know if the last value added improved the best value or not by calling the <code>has_improved</code> method.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.has_improved()\nTrue\n&gt;&gt;&gt; record.add_value(60)\n&gt;&gt;&gt; record.has_improved()\nFalse\n&gt;&gt;&gt; record.add_value(42)\n&gt;&gt;&gt; record.has_improved()\nTrue\n&gt;&gt;&gt; record.add_value(43)\n&gt;&gt;&gt; record.has_improved()\nFalse\n</code></pre> <p>By definition, <code>has_improved</code> will return <code>True</code> if the last value is equal to the best value as shown in the example below.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record.add_value(42)\n&gt;&gt;&gt; record.has_improved()\nTrue\n&gt;&gt;&gt; record.add_value(42)\n&gt;&gt;&gt; record.has_improved()\nTrue\n</code></pre> <p> Calling <code>has_improved</code> or <code>get_best_value</code> on non-comparable record raises a <code>NotAComparableRecord</code> exception.</p> <p> Note about constructors: the constructor of <code>ComparableRecord</code> works slightly differently from <code>Record</code>. If you pass some elements to the constructor, you also need to pass the <code>best_value</code> and <code>improved</code> arguments to have the correct behavior. It is not a mistake but the expected behavior as the best value can be outside of the values store in the record.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; # Incorrect behavior\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.get_best_value()\n50\n&gt;&gt;&gt; # Correct behavior\n&gt;&gt;&gt; record = MinScalarRecord(\"loss\")\n&gt;&gt;&gt; record.update([(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.get_best_value()\n42\n</code></pre> <p>To automatically instantiate the record based on the input elements, you can use the <code>from_elements</code> class method.</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord.from_elements(\"loss\", elements=[(0, 42), (None, 45), (2, 46)])\n&gt;&gt;&gt; record.add_value(50)\n&gt;&gt;&gt; record.get_best_value()\n42\n</code></pre>"},{"location":"refs/comparator/","title":"minrecord.comparator","text":""},{"location":"refs/comparator/#minrecord.comparator","title":"minrecord.comparator","text":"<p>Contain the comparator base class and some implementations.</p>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator","title":"minrecord.comparator.BaseComparator","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Define the base comparator class to implement a comparator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator.equal","title":"minrecord.comparator.BaseComparator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two comparators are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the comparators are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator, MaxScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.equal(MinScalarComparator())\nTrue\n&gt;&gt;&gt; comparator.equal(MaxScalarComparator())\nFalse\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator.get_initial_best_value","title":"minrecord.comparator.BaseComparator.get_initial_best_value  <code>abstractmethod</code>","text":"<pre><code>get_initial_best_value() -&gt; T\n</code></pre> <p>Get the initial best value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The initial best value.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.BaseComparator.is_better","title":"minrecord.comparator.BaseComparator.is_better  <code>abstractmethod</code>","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.ComparatorEqualityComparator","title":"minrecord.comparator.ComparatorEqualityComparator","text":"<p>               Bases: <code>BaseEqualityComparator[BaseComparator]</code></p> <p>Implement an equality comparator for <code>BaseBatch</code> objects.</p>"},{"location":"refs/comparator/#minrecord.comparator.MaxScalarComparator","title":"minrecord.comparator.MaxScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implement a max comparator for scalar value.</p> <p>This comparator can be used to find the maximum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarComparator\n&gt;&gt;&gt; comparator = MaxScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nTrue\n&gt;&gt;&gt; comparator.get_initial_best_value()\n-inf\n</code></pre>"},{"location":"refs/comparator/#minrecord.comparator.MinScalarComparator","title":"minrecord.comparator.MinScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implementation of a min comparator for scalar value.</p> <p>This comparator can be used to find the minimum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/","title":"minrecord","text":""},{"location":"refs/root/#minrecord","title":"minrecord","text":"<p>Root package.</p>"},{"location":"refs/root/#minrecord.BaseComparator","title":"minrecord.BaseComparator","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Define the base comparator class to implement a comparator.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/#minrecord.BaseComparator.equal","title":"minrecord.BaseComparator.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two comparators are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the comparators are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator, MaxScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.equal(MinScalarComparator())\nTrue\n&gt;&gt;&gt; comparator.equal(MaxScalarComparator())\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.BaseComparator.get_initial_best_value","title":"minrecord.BaseComparator.get_initial_best_value  <code>abstractmethod</code>","text":"<pre><code>get_initial_best_value() -&gt; T\n</code></pre> <p>Get the initial best value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The initial best value.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/#minrecord.BaseComparator.is_better","title":"minrecord.BaseComparator.is_better  <code>abstractmethod</code>","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord","title":"minrecord.BaseRecord","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Define the base class to implement a record.</p> <p>The record tracks the value added as well as the step when the value is added. The goal of this class is to track the recent record because the loggers (e.g. MLFlow or Tensorboard) do not allow to get the last value or the best value. The record keeps in memory a recent record of pairs (step, value) where step is the index of the step when the value was added. The length of the recent record depends on the concrete implementation.</p> <p>To implement your own record, you will need to define the following methods:</p> <pre><code>- ``add_value``\n- ``get_last_value``\n- ``get_most_recent``\n- ``is_comparable``\n- ``is_empty``\n- ``update``\n- ``load_state_dict``\n- ``state_dict``\n</code></pre> <p>If it is a comparable record, you will need to implement the following methods too:</p> <pre><code>- ``_get_best_value``\n- ``_has_improved``\n</code></pre> <p>You may also need to extend the <code>config_dict</code> method.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.get_last_value()\n1.2\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.name","title":"minrecord.BaseRecord.name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the record.</p>"},{"location":"refs/root/#minrecord.BaseRecord.add_value","title":"minrecord.BaseRecord.add_value  <code>abstractmethod</code>","text":"<pre><code>add_value(value: T, step: float | None = None) -&gt; None\n</code></pre> <p>Add a new value to the record.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to add to the record.</p> required <code>step</code> <code>float | None</code> <p>The step value to record. <code>None</code> means there is no step to track.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2)\n&gt;&gt;&gt; record.add_value(value=42, step=1)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=2)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.clone","title":"minrecord.BaseRecord.clone","text":"<pre><code>clone() -&gt; BaseRecord\n</code></pre> <p>Clone the current record.</p> <p>Returns:</p> Type Description <code>BaseRecord</code> <p>A copy of the current record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"epoch\")\n&gt;&gt;&gt; record_cloned = record.clone()\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.config_dict","title":"minrecord.BaseRecord.config_dict","text":"<pre><code>config_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get the config of the record.</p> <p>The config dictionary should contain all the values necessary to instantiate a record with the same parameters with the  <code>factory</code> method. It is expected to contain values like the full name of the class and the arguments of the constructor. This dictionary should not contain the state values. It is possible to get the state values with the <code>state_dict</code> method.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The config of the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord, Record\n&gt;&gt;&gt; config = Record(\"loss\").config_dict()\n&gt;&gt;&gt; record = BaseRecord.factory(**config)  # Note that the state is not copied.\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=0)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.equal","title":"minrecord.BaseRecord.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Indicate if two records are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The object to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the records are equal, <code>False</code> otherwise.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record1 = Record(\"loss\")\n&gt;&gt;&gt; record2 = Record(\"accuracy\")\n&gt;&gt;&gt; record3 = Record(\"loss\")\n&gt;&gt;&gt; record1.equal(record2)\nFalse\n&gt;&gt;&gt; record1.equal(record1)\nTrue\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.from_dict","title":"minrecord.BaseRecord.from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict) -&gt; BaseRecord\n</code></pre> <p>Instantiate a record from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary that is used to instantiate the record. The dictionary is expected to contain the parameters to create instantiate the record and the state of the record.</p> required <p>Returns:</p> Type Description <code>BaseRecord</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord\n&gt;&gt;&gt; from objectory import OBJECT_TARGET\n&gt;&gt;&gt; record = BaseRecord.from_dict(\n...     {\n...         \"config\": {\n...             OBJECT_TARGET: \"minrecord.Record\",\n...             \"name\": \"loss\",\n...             \"max_size\": 7,\n...         },\n...         \"state\": {\"record\": ((0, 1), (1, 5))},\n...     }\n... )\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=7, size=2)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.get_best_value","title":"minrecord.BaseRecord.get_best_value","text":"<pre><code>get_best_value() -&gt; T\n</code></pre> <p>Get the best value of this record.</p> <p>It is possible to get the best value only if it is a comparable record i.e. it is possible to compare the values in the record.</p> <p>Returns:</p> Type Description <code>T</code> <p>The best value of this record.</p> <p>Raises:</p> Type Description <code>NotAComparableRecord</code> <p>if it is not a comparable record.</p> <code>EmptyRecordError</code> <p>if the record is empty</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=4, step=1)\n&gt;&gt;&gt; record.get_best_value()\n4\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.get_last_value","title":"minrecord.BaseRecord.get_last_value  <code>abstractmethod</code>","text":"<pre><code>get_last_value() -&gt; T\n</code></pre> <p>Get the last value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The last value added in the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.get_last_value()\n1.2\n&gt;&gt;&gt; record.add_value(value=0.8, step=1)\n&gt;&gt;&gt; record.get_last_value()\n0.8\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.get_most_recent","title":"minrecord.BaseRecord.get_most_recent  <code>abstractmethod</code>","text":"<pre><code>get_most_recent() -&gt; tuple[tuple[float | None, T], ...]\n</code></pre> <p>Get the tuple of recent values and their associated steps.</p> <p>The last value in the tuple is the last value added to the record. The length of the recent record depends on the concrete implementation.</p> <p>Returns:</p> Type Description <code>tuple[tuple[float | None, T], ...]</code> <p>A tuple of the recent values in the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(value=2)\n&gt;&gt;&gt; record.add_value(value=1.2, step=1)\n&gt;&gt;&gt; record.add_value(value=0.8, step=2)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 2), (1, 1.2), (2, 0.8))\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.has_improved","title":"minrecord.BaseRecord.has_improved","text":"<pre><code>has_improved() -&gt; bool\n</code></pre> <p>Indicate if the last value is the best value.</p> <p>It is possible to use this method only if it is a comparable record i.e. it is possible to compare the values in the record.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the last value is the best value, otherwise <code>False</code>.</p> <p>Raises:</p> Type Description <code>NotAComparableRecord</code> <p>if it is not a comparable record.</p> <code>EmptyRecordError</code> <p>if the record is empty</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"accuracy\")\n&gt;&gt;&gt; record.add_value(value=2, step=0)\n&gt;&gt;&gt; record.add_value(value=4, step=1)\n&gt;&gt;&gt; record.has_improved()\nTrue\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.is_comparable","title":"minrecord.BaseRecord.is_comparable  <code>abstractmethod</code>","text":"<pre><code>is_comparable() -&gt; bool\n</code></pre> <p>Indicate if it is possible to compare the values in the record.</p> <p>Note that it is possible to compute the best value only for records that are comparable.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if it is possible to compare the values in the record, otherwise <code>False</code>.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_comparable()\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.is_empty","title":"minrecord.BaseRecord.is_empty  <code>abstractmethod</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Indicate if the record is empty or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the record is empty, otherwise <code>False</code>.</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.is_empty()\nTrue\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.load_state_dict","title":"minrecord.BaseRecord.load_state_dict  <code>abstractmethod</code>","text":"<pre><code>load_state_dict(state_dict: dict[str, Any]) -&gt; None\n</code></pre> <p>Set up the record from a dictionary containing the state values.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict[str, Any]</code> <p>A dictionary containing state keys with values.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.load_state_dict({\"record\": ((0, 42.0),)})\n&gt;&gt;&gt; record.get_last_value()\n42.0\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.state_dict","title":"minrecord.BaseRecord.state_dict  <code>abstractmethod</code>","text":"<pre><code>state_dict() -&gt; dict[str, Any]\n</code></pre> <p>Get a dictionary containing the state values of the record.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The state values in a dict.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.add_value(42.0, step=0)\n&gt;&gt;&gt; state = record.state_dict()\n&gt;&gt;&gt; state\n{'record': ((0, 42.0),)}\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.to_dict","title":"minrecord.BaseRecord.to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Export the current record to a dictionary.</p> <p>This method exports all the information to re-create the record with the same state. The returned dictionary can be used as input of the <code>from_dict</code> method to resume the record.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary with the config and the state of the record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import BaseRecord, Record\n&gt;&gt;&gt; record_dict = Record(\"loss\").to_dict()\n&gt;&gt;&gt; record = BaseRecord.from_dict(record_dict)\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=0)\n</code></pre>"},{"location":"refs/root/#minrecord.BaseRecord.update","title":"minrecord.BaseRecord.update  <code>abstractmethod</code>","text":"<pre><code>update(elements: Iterable[tuple[float | None, T]]) -&gt; None\n</code></pre> <p>Update the record by adding the elements.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The elements to add to the record.  Each tuple has the following structure <code>(step, value)</code>. The step can be <code>None</code> if there is no step.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(\"loss\")\n&gt;&gt;&gt; record.update([(0, 42), (1, 45)])\n&gt;&gt;&gt; record\nRecord(name=loss, max_size=10, size=2)\n</code></pre>"},{"location":"refs/root/#minrecord.ComparableRecord","title":"minrecord.ComparableRecord","text":"<p>               Bases: <code>Record[T]</code></p> <p>Implement a record of comparable values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>comparator</code> <code>BaseComparator[T]</code> <p>The comparator to use to find the best value.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import ComparableRecord\n&gt;&gt;&gt; from minrecord.comparator import MaxScalarComparator\n&gt;&gt;&gt; record = ComparableRecord(\"value\", MaxScalarComparator())\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.ComparableRecord.is_better","title":"minrecord.ComparableRecord.is_better","text":"<pre><code>is_better(old_value: T, new_value: T) -&gt; bool\n</code></pre> <p>Indicate if the new value is better than the old value.</p> <p>Parameters:</p> Name Type Description Default <code>old_value</code> <code>T</code> <p>The old value to compare.</p> required <code>new_value</code> <code>T</code> <p>The new value to compare.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the new value is better than the old value, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import ComparableRecord\n&gt;&gt;&gt; from minrecord.comparator import MaxScalarComparator\n&gt;&gt;&gt; record = ComparableRecord(\"accuracy\", MaxScalarComparator())\n&gt;&gt;&gt; record.is_better(new_value=1, old_value=0)\nTrue\n&gt;&gt;&gt; record.is_better(new_value=0, old_value=1)\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.EmptyRecordError","title":"minrecord.EmptyRecordError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise an error if the record is empty.</p>"},{"location":"refs/root/#minrecord.MaxScalarComparator","title":"minrecord.MaxScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implement a max comparator for scalar value.</p> <p>This comparator can be used to find the maximum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarComparator\n&gt;&gt;&gt; comparator = MaxScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nTrue\n&gt;&gt;&gt; comparator.get_initial_best_value()\n-inf\n</code></pre>"},{"location":"refs/root/#minrecord.MaxScalarRecord","title":"minrecord.MaxScalarRecord","text":"<p>               Bases: <code>ComparableRecord[Number]</code></p> <p>A specific implementation to track the max value of a scalar record.</p> <p>This record uses the <code>MaxScalarComparator</code> to find the best value of the record.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord(\"value\")\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.MaxScalarRecord.from_elements","title":"minrecord.MaxScalarRecord.from_elements  <code>classmethod</code>","text":"<pre><code>from_elements(\n    name: str, elements: Iterable[tuple[float | None, T]]\n) -&gt; Self\n</code></pre> <p>Instantiate a <code>MaxScalarRecord</code> object from the elements.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MaxScalarRecord\n&gt;&gt;&gt; record = MaxScalarRecord.from_elements(\"value\", ((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n64.0\n</code></pre>"},{"location":"refs/root/#minrecord.MinScalarComparator","title":"minrecord.MinScalarComparator","text":"<p>               Bases: <code>BaseComparator[float]</code></p> <p>Implementation of a min comparator for scalar value.</p> <p>This comparator can be used to find the minimum value between two scalar values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarComparator\n&gt;&gt;&gt; comparator = MinScalarComparator()\n&gt;&gt;&gt; comparator.is_better(old_value=0.4, new_value=0.6)\nFalse\n&gt;&gt;&gt; comparator.get_initial_best_value()\ninf\n</code></pre>"},{"location":"refs/root/#minrecord.MinScalarRecord","title":"minrecord.MinScalarRecord","text":"<p>               Bases: <code>ComparableRecord[Number]</code></p> <p>A specific implementation to track the min value of a scalar record.</p> <p>This record uses the <code>MinScalarComparator</code> to find the best value of the record.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum number of elements to store inthe record.</p> <code>10</code> <code>best_value</code> <code>T | None</code> <p>The initial best value. If <code>None</code>, the initial best  value of the <code>comparator</code> is used.</p> <code>None</code> <code>improved</code> <code>bool</code> <p>Indicate if the last value is the best value or not.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord(\"value\")\n&gt;&gt;&gt; record.add_value(64.0)\n&gt;&gt;&gt; record.add_value(42.0)\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n42.0\n</code></pre>"},{"location":"refs/root/#minrecord.MinScalarRecord.from_elements","title":"minrecord.MinScalarRecord.from_elements  <code>classmethod</code>","text":"<pre><code>from_elements(\n    name: str, elements: Iterable[tuple[float | None, T]]\n) -&gt; Self\n</code></pre> <p>Instantiate a <code>MaxScalarRecord</code> object from the elements.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[float | None, T]]</code> <p>The initial elements. Each element is a tuple with the step and its associated value.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instantiated record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import MinScalarRecord\n&gt;&gt;&gt; record = MinScalarRecord.from_elements(\"value\", ((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_best_value()\n42.0\n</code></pre>"},{"location":"refs/root/#minrecord.NotAComparableRecordError","title":"minrecord.NotAComparableRecordError","text":"<p>               Bases: <code>Exception</code></p> <p>Raise an error if it is not possible to compare the values in the record.</p>"},{"location":"refs/root/#minrecord.Record","title":"minrecord.Record","text":"<p>               Bases: <code>BaseRecord[T]</code></p> <p>Implement a generic record to store the recent values.</p> <p>Internally, this class uses a <code>deque</code> to keep the most recent values added in the record. Note that this class does not allow to get the best value because it is not possible to define a generic rule to know the best object. Please see <code>ScalarRecord</code> that can compute the best value for scalars.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the record.</p> required <code>elements</code> <code>Iterable[tuple[int | None, T]]</code> <p>The initial elements in the record. Each element is a tuple with the step and its associated value.</p> <code>()</code> <code>max_size</code> <code>int</code> <p>The maximum size of the record.</p> <code>get_max_size()</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import Record\n&gt;&gt;&gt; record = Record(name=\"value\", elements=((None, 64.0), (None, 42.0)))\n&gt;&gt;&gt; record\nRecord(name=value, max_size=10, size=2)\n&gt;&gt;&gt; record.get_last_value()\n42.0\n&gt;&gt;&gt; record.get_most_recent()\n((None, 64.0), (None, 42.0))\n</code></pre>"},{"location":"refs/root/#minrecord.Record.max_size","title":"minrecord.Record.max_size  <code>property</code>","text":"<pre><code>max_size: int\n</code></pre> <p><code>int</code>: The maximum size of the record.</p>"},{"location":"refs/root/#minrecord.RecordManager","title":"minrecord.RecordManager","text":"<p>Implement a simple record manager.</p> <p>This class proposes an approach to manage a group of records, but it is possible to use other approaches. If this class does not fit your needs, feel free to use another approach.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>dict[str, BaseRecord] | None</code> <p>The initial records to add to the manager.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.get_record(\"loss\")\nMinScalarRecord(name=loss, max_size=10, size=0)\n&gt;&gt;&gt; manager.get_record(\"new_record\")\nRecord(name=new_record, max_size=10, size=0)\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.add_record","title":"minrecord.RecordManager.add_record","text":"<pre><code>add_record(\n    record: BaseRecord,\n    key: str | None = None,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add a record to the manager.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>BaseRecord</code> <p>The record to add to the manager.</p> required <code>key</code> <code>str | None</code> <p>The key to store the record. If <code>None</code>, the name of the record is used.</p> <code>None</code> <code>exist_ok</code> <code>bool</code> <p>If <code>False</code>, <code>RuntimeError</code> is raised if the key already exists. This parameter should be set to <code>True</code> to overwrite the record for this key.</p> <code>False</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if a record is already registered for the key and <code>exist_ok=False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager\nRecordManager(\n  (loss): MinScalarRecord(name=loss, max_size=10, size=0)\n)\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"), \"my key\")\n&gt;&gt;&gt; manager\nRecordManager(\n  (loss): MinScalarRecord(name=loss, max_size=10, size=0)\n  (my key): MinScalarRecord(name=loss, max_size=10, size=0)\n)\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.get_best_values","title":"minrecord.RecordManager.get_best_values","text":"<pre><code>get_best_values(\n    prefix: str = \"\", suffix: str = \"\"\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the best value of each metric.</p> <p>This method ignores the metrics with empty record and the non-comparable record.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the metric name to avoid confusion. By default, the returned dict uses the same name as the metric.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the metric name to avoid confusion. By default, the returned dict uses the same name as the metric.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each metric.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MaxScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MaxScalarRecord(\"accuracy\"))\n&gt;&gt;&gt; manager.get_record(\"accuracy\").add_value(42.0)\n&gt;&gt;&gt; manager.get_best_values()\n{'accuracy': 42.0}\n&gt;&gt;&gt; manager.get_best_values(prefix=\"best/\")\n{'best/accuracy': 42.0}\n&gt;&gt;&gt; manager.get_best_values(suffix=\"/best\")\n{'accuracy/best': 42.0}\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.get_record","title":"minrecord.RecordManager.get_record","text":"<pre><code>get_record(key: str) -&gt; BaseRecord\n</code></pre> <p>Get the record associated to a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the record to retrieve.</p> required <p>Returns:</p> Type Description <code>BaseRecord</code> <p>The record if it exists, otherwise it returns an empty record. The created empty record is a <code>Record</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.get_record(\"loss\")\nMinScalarRecord(name=loss, max_size=10, size=0)\n&gt;&gt;&gt; manager.get_record(\"new_record\")\nRecord(name=new_record, max_size=10, size=0)\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.get_records","title":"minrecord.RecordManager.get_records","text":"<pre><code>get_records() -&gt; dict[str, BaseRecord]\n</code></pre> <p>Get all the records.</p> <p>Returns:</p> Type Description <code>dict[str, BaseRecord]</code> <p>The records with their associated keys.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.get_records()\n{'loss': MinScalarRecord(name=loss, max_size=10, size=0)}\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.has_record","title":"minrecord.RecordManager.has_record","text":"<pre><code>has_record(key: str) -&gt; bool\n</code></pre> <p>Indicate if the engine has a record for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the record to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the record exists, <code>False</code> otherwise</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, MinScalarRecord\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(MinScalarRecord(\"loss\"))\n&gt;&gt;&gt; manager.has_record(\"loss\")\nTrue\n&gt;&gt;&gt; manager.has_record(\"missing\")\nFalse\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.load_state_dict","title":"minrecord.RecordManager.load_state_dict","text":"<pre><code>load_state_dict(state_dict: dict) -&gt; None\n</code></pre> <p>Load the state values from a dict.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict</code> <p>A dict with the new state values.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager, Record\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.add_record(Record(\"value\"))\n&gt;&gt;&gt; manager.load_state_dict({\"value\": {\"state\": {\"record\": ((0, 1), (1, 0.5), (2, 0.25))}}})\n&gt;&gt;&gt; manager.get_record(\"value\").get_last_value()\n0.25\n</code></pre>"},{"location":"refs/root/#minrecord.RecordManager.state_dict","title":"minrecord.RecordManager.state_dict","text":"<pre><code>state_dict() -&gt; dict\n</code></pre> <p>Return a dictionary containing state values of all the records.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The dictionary containing state values of all the records.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import RecordManager\n&gt;&gt;&gt; manager = RecordManager()\n&gt;&gt;&gt; manager.state_dict()\n{}\n</code></pre>"},{"location":"refs/root/#minrecord.get_best_values","title":"minrecord.get_best_values","text":"<pre><code>get_best_values(\n    records: Mapping[str, BaseRecord],\n    prefix: str = \"\",\n    suffix: str = \"\",\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the best value of each record.</p> <p>This function ignores the empty and non-comparable records.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Mapping[str, BaseRecord]</code> <p>The records and their associated keys.</p> required <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import (\n...     MinScalarRecord,\n...     MaxScalarRecord,\n...     get_best_values,\n... )\n&gt;&gt;&gt; record1 = MinScalarRecord.from_elements(\"loss\", elements=[(None, 1.9), (None, 1.2)])\n&gt;&gt;&gt; record2 = MaxScalarRecord.from_elements(\"accuracy\", elements=[(None, 42), (None, 35)])\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2})\n{'loss': 1.2, 'accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, prefix=\"best/\")\n{'best/loss': 1.2, 'best/accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, suffix=\"/best\")\n{'loss/best': 1.2, 'accuracy/best': 42}\n</code></pre>"},{"location":"refs/root/#minrecord.get_last_values","title":"minrecord.get_last_values","text":"<pre><code>get_last_values(\n    records: Mapping[str, BaseRecord],\n    prefix: str = \"\",\n    suffix: str = \"\",\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the last value of each record.</p> <p>This function ignores the empty records.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>Mapping[str, BaseRecord]</code> <p>The records and their associated keys.</p> required <code>prefix</code> <code>str</code> <p>The prefix used to create the dict of best values. The goal of this prefix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <code>suffix</code> <code>str</code> <p>The suffix used to create the dict of best values. The goal of this suffix is to generate a name which is different from the record name to avoid confusion. By default, the returned dict uses the same name as the record.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The dict with the best value of each record.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import (\n...     MinScalarRecord,\n...     MaxScalarRecord,\n...     get_best_values,\n... )\n&gt;&gt;&gt; record1 = MinScalarRecord.from_elements(\"loss\", elements=[(None, 1.9), (None, 1.2)])\n&gt;&gt;&gt; record2 = MaxScalarRecord.from_elements(\"accuracy\", elements=[(None, 42), (None, 35)])\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2})\n{'loss': 1.2, 'accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, prefix=\"best/\")\n{'best/loss': 1.2, 'best/accuracy': 42}\n&gt;&gt;&gt; get_best_values({\"loss\": record1, \"accuracy\": record2}, suffix=\"/best\")\n{'loss/best': 1.2, 'accuracy/best': 42}\n</code></pre>"},{"location":"refs/root/#minrecord.get_max_size","title":"minrecord.get_max_size","text":"<pre><code>get_max_size() -&gt; int\n</code></pre> <p>Get the current default maximum size of values to track in each record.</p> <p>Returns:</p> Type Description <code>int</code> <p>The current default maximum size of values to track in each record.</p> <p>This value can be changed by using <code>set_max_size</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import get_max_size\n&gt;&gt;&gt; get_max_size()\n10\n</code></pre>"},{"location":"refs/root/#minrecord.set_max_size","title":"minrecord.set_max_size","text":"<pre><code>set_max_size(max_size: int) -&gt; None\n</code></pre> <p>Set the default maximum size of values to track in each record.</p> <p>This function does not change the maximum size of records that are already created. It only changes the maximum size of records that will be created after the call of this function.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>The new default maximum size of values to track in each record.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord import get_max_size, set_max_size\n&gt;&gt;&gt; get_max_size()\n10\n&gt;&gt;&gt; set_max_size(5)\n&gt;&gt;&gt; get_max_size()\n5\n</code></pre>"},{"location":"refs/utils/","title":"minrecord.utils","text":""},{"location":"refs/utils/#minrecord.utils","title":"minrecord.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#minrecord.utils.value","title":"minrecord.utils.value","text":"<p>Contain utility functions to manage objects.</p>"},{"location":"refs/utils/#minrecord.utils.value.MutableValue","title":"minrecord.utils.value.MutableValue","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Implement a simple class to build a mutable object.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The initial value.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from minrecord.utils.value import MutableValue\n&gt;&gt;&gt; value = MutableValue(10)\n&gt;&gt;&gt; value.get_value()\n10\n&gt;&gt;&gt; value.set_value(42)\n&gt;&gt;&gt; value.get_value()\n42\n</code></pre>"},{"location":"refs/utils/#minrecord.utils.value.MutableValue.get_value","title":"minrecord.utils.value.MutableValue.get_value","text":"<pre><code>get_value() -&gt; T\n</code></pre> <p>Get the current value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value.</p>"},{"location":"refs/utils/#minrecord.utils.value.MutableValue.set_value","title":"minrecord.utils.value.MutableValue.set_value","text":"<pre><code>set_value(value: T) -&gt; None\n</code></pre> <p>Set a new value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The new value.</p> required"}]}